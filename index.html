<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Control Roster</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Supabase JS CDN -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <style>
    /* ===== Global layout ===== */
    html, body {
      width: 100%;
      max-width: 100%;
      margin: 0;
      padding: 0;
      overflow-x: auto;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #d8dce3;
      color: #0f172a;
    }

    header {
      padding: 0.75rem 1rem;
      background: #f5f6f8;
      border-bottom: 1px solid #b8bfc9;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    header h1 {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 600;
      color: #0f172a;
    }
    header span {
      font-size: 0.85rem;
      color: #475569;
    }

    .container {
      padding: 0.75rem 1rem;
      max-width: 100%;
      width: 100%;
      margin: 0;
    }

    .card {
      background: #f2f3f5;
      border-radius: 0.75rem;
      border: 1px solid #b8bfc9;
      padding: 1rem 1.25rem;
      margin-bottom: 1rem;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
    }
    .card h2 {
      margin: 0 0 0.5rem;
      font-size: 1rem;
      color: #0f172a;
    }
    .muted {
      color: #475569;
      font-size: 0.8rem;
    }

    /* ===== Buttons ===== */
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.45rem 0.8rem;
      border-radius: 999px;
      border: 1px solid #b8bfc9;
      background: #e2e6eb;
      color: #0f172a;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease;
    }
    .btn:hover {
      background: #d5d9e2;
      border-color: #aeb6c4;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.12);
    }
    .btn-primary {
      border-color: #2563eb;
      background: #3b82f6;
      color: #ffffff;
    }
    .btn-primary:hover {
      background: #2563eb;
      border-color: #1d4ed8;
    }
    .btn-danger {
      border-color: #dc2626;
      background: #ef4444;
      color: #ffffff;
    }
    .btn-sm {
      padding: 0.25rem 0.6rem;
      font-size: 0.7rem;
    }

    /* Tag tray buttons */
    .tag-tray-btn-active {
      background: #1f2937;
      color: #f9fafb;
      border-color: #111827;
    }

.uncovered-selected{
  outline: 3px solid #111827;
  outline-offset: 1px;
}

    /* ===== Inputs & selects ===== */
    input, select, textarea {
      background: #f3f4f6;
      border-radius: 0.4rem;
      border: 1px solid #b8bfc9;
      color: #0f172a;
      padding: 0.35rem 0.55rem;
      font-size: 0.8rem;
      box-sizing: border-box;
    }
    input::placeholder {
      color: #9ca3af;
    }
    input:focus, select:focus, textarea:focus {
      outline: 2px solid #3b82f6;
      outline-offset: 1px;
      border-color: #3b82f6;
    }

    /* ===== Table / roster area ===== */
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.8rem;
      background: #e3e6ee; /* darker so it stands out from card */
    }
    th, td {
      border: 1px solid #b8bfc9;
      padding: 0.3rem 0.4rem;
      text-align: center;
      vertical-align: top;
    }
    thead {
      background: #d3d7e0; /* a shade darker than before */
      position: sticky;
      top: 0;
      z-index: 2;
    }
    thead th {
      font-weight: 600;
      color: #0f172a;
    }

    .roster-grid {
      max-width: 100%;
      width: 100%;
      max-height: 70vh;
      overflow-y: auto;
      overflow-x: auto;
      margin-top: 0.5rem;
      background: #eef0f3;
      border-radius: 0.5rem;
      border: 1px solid #c4c9d2;
      padding: 0.25rem;
    }

    /* Horizontal scroll helper for wide tables */
    .table-scroll-x {
      width: 100%;
      overflow-x: auto;
    }

    /* Tight name & remarks columns */
    .roster-grid table th:first-child,
    .roster-grid table td:first-child {
      width: 130px;
      max-width: 130px;
    }

    .roster-grid table th:last-child,
    .roster-grid table td:last-child {
      width: 160px;
      max-width: 160px;
    }

    /* Name input: clamp horizontally, ellipsis if too long */
    .roster-grid table td:first-child input {
      width: 100%;
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Remarks: allow vertical growth */
    .remark-input {
      width: 100%;
      font-size: 0.75rem;
      min-height: 1.6rem;
      resize: vertical;
      box-sizing: border-box;
    }

/* ===== Weekly trends heatmap (0â€“35) ===== */
.hm{
  font-weight: 700;
  border-radius: 0.35rem;
}

/* 0 */
.hm-0  { background:#dcfce7; color:#166534; }

/* 1â€“5 */
.hm-1  { background:#ecfccb; color:#3f6212; }

/* 6â€“10 */
.hm-2  { background:#fef9c3; color:#854d0e; }

/* 11â€“15 */
.hm-3  { background:#fed7aa; color:#9a3412; }

/* 16â€“20 */
.hm-4  { background:#fecaca; color:#991b1b; }

/* 21â€“25 */
.hm-5  { background:#fca5a5; color:#7f1d1d; }

/* 26â€“35+ */
.hm-6  { background:#7f1d1d; color:#ffffff; }

    /* ===== Desktop roster sizing ===== */
    .roster-grid table.roster-table {
      table-layout: fixed;
    }

    .roster-grid table.roster-table th,
    .roster-grid table.roster-table td {
      padding: 0.25rem 0.3rem;
      font-size: 0.78rem;
    }

    .roster-grid table.roster-table th:nth-child(1),
    .roster-grid table.roster-table td:nth-child(1) {
      width: 180px;
      max-width: 180px;
    }

    .roster-grid table.roster-table th:nth-child(2),
    .roster-grid table.roster-table td:nth-child(2),
    .roster-grid table.roster-table th:nth-child(3),
    .roster-grid table.roster-table td:nth-child(3),
    .roster-grid table.roster-table th:nth-child(4),
    .roster-grid table.roster-table td:nth-child(4),
    .roster-grid table.roster-table th:nth-child(5),
    .roster-grid table.roster-table td:nth-child(5),
    .roster-grid table.roster-table th:nth-child(6),
    .roster-grid table.roster-table td:nth-child(6),
    .roster-grid table.roster-table th:nth-child(7),
    .roster-grid table.roster-table td:nth-child(7),
    .roster-grid table.roster-table th:nth-child(8),
    .roster-grid table.roster-table td:nth-child(8) {
      width: 70px;
      max-width: 70px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .roster-grid table.roster-table th:nth-child(9),
    .roster-grid table.roster-table td:nth-child(9) {
      width: 220px;
      max-width: 220px;
    }

    /* ===== Shift cell layout ===== */
    .shift-cell-wrap {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.3rem; /* increased gap for more room under shifts */
    }

    .shift-input {
      flex: 1;
      min-width: 0;
      background: #ffffff;
      font-weight: 700;
      color: #000000 !important;
      font-size: 0.8rem;
    }

    /* Tag row under each shift */
    .tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.15rem;
    }
    .tag-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 0.05rem 0.35rem;
      font-size: 0.6rem;
      border: 1px solid #cbd5e1;
      background: #f3f4f6;
      color: #475569;
      white-space: nowrap;
    }
    .tag-pill-rdw {
      background: #2c2cd9;
      border-color: #2c2cd9;
      color: #ffffff;
      font-weight: 700;
    }
    .tag-pill-al {
      background: #ff0000;
      border-color: #b91c1c;
      color: #ffffff;
      font-weight: 700;
    }
    .tag-pill-cl {
      background: #f97316;
      border-color: #ea580c;
      color: #ffffff;
      font-weight: 700;
    }
    .tag-pill-sick {
      background: #4d7c0f;
      border-color: #3f6212;
      color: #ffffff;
      font-weight: 700;
    }
    .tag-pill-bo {
      background: #991b1b;
      border-color: #7f1d1d;
      color: #ffffff;
      font-weight: 700;
    }
    .tag-pill-rop {
      background: #c4b5fd;
      border-color: #a855f7;
      color: #312e81;
      font-weight: 700;
    }
    .tag-pill-hgd {
      background: #e5e7eb;
      border-color: #9ca3af;
      color: #111827;
    }

    /* ===== Conditional formatting ===== */
    .shift-day {
      background: #f1a983;
      color: #7c2d12;
    }
    .shift-night {
      background: #4d93d9;
      color: #1e3a8a;
    }
    .shift-spare {
      background: #d86dcd;
      color: #701a75;
    }
    .shift-oo {
      background: #ffff00;
      color: #854d0e;
    }
.shift-12oc {
  background: #b5b5b5;
  color: #000000 !important;
}
    .shift-al {
      background: #ff0000;
      color: #ffffff !important;
      text-decoration: line-through;
    }
    .shift-cl {
      background: #ff0000;
      color: #ffffff !important;
      text-decoration: line-through;
    }
    .shift-sick {
      background: #4d7c0f;
      color: #ffffff !important;
      text-decoration: line-through;
    }
    .shift-rd {
      background: #f3f4f6;
      color: #6b7280;
      font-style: italic;
    }
    .shift-bo {
      background: #ff0000;
      color: #ffffff !important;
      text-decoration: line-through;
    }
    .shift-rop {
      font-weight: 900;
    }

    /* Spare-origin marker (originally SPARE in base roster) */
    .spare-origin-cell {
      position: relative;
    }
    .spare-origin-cell::before {
      content: "";
      position: absolute;
      left: 2px;
      top: 2px;
      bottom: 2px;
      width: 4px;
      border-radius: 999px;
      background: #d86dcd;
      pointer-events: none;
    }

    /* Tags and status pills */
    .tag {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 0.15rem 0.4rem;
      font-size: 0.7rem;
      border: 1px solid #cbd2dd;
      color: #4b5563;
      background: #eef0f3;
    }
    .status-pill {
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid #b8bfc9;
      background: #f2f3f5;
    }
    .status-draft {
      border-color: #f59e0b;
      color: #92400e;
      background: #fffbeb;
    }
    .status-published {
      border-color: #22c55e;
      color: #15803d;
      background: #ecfdf3;
    }

    /* Layout helpers */
    .flex {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .flex-between {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .mt-1 { margin-top: 0.25rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 0.75rem; }
    .mb-1 { margin-bottom: 0.25rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .w-100 { width: 100%; }
    .hidden { display: none; }

    /* Alt row shading for per-person totals */
    #analytics-usage-tbody tr:nth-child(even),
    #analytics-leave-tbody tr:nth-child(even),
    #analytics-expiry-tbody tr:nth-child(even) {
      background: #e5e7eb;
    }

    /* Coverage banner styling */
    .coverage-panel {
      background: #e0f2fe;
      border-radius: 0.5rem;
      border: 1px solid #bae6fd;
      padding: 0.35rem 0.6rem;
      font-size: 0.8rem;
      color: #0f172a;
    }
    .coverage-top-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .coverage-pill {
      border-radius: 999px;
      padding: 0.15rem 0.6rem;
      font-size: 0.75rem;
      border: 1px solid transparent;
      font-weight: 600;
      white-space: nowrap;
    }
    .coverage-pill.cov-good {
      background: #dcfce7;
      border-color: #22c55e;
      color: #166534;
    }
    .coverage-pill.cov-amber {
      background: #fef9c3;
      border-color: #facc15;
      color: #854d0e;
    }
    .coverage-pill.cov-red {
      background: #fee2e2;
      border-color: #ef4444;
      color: #991b1b;
    }
    .coverage-summary-text {
      font-size: 0.8rem;
      color: #0f172a;
    }
    .coverage-legend {
      margin-top: 0.35rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: #475569;
    }
    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }
    .legend-swatch {
      width: 0.75rem;
      height: 0.75rem;
      border-radius: 0.2rem;
      border: 1px solid #cbd5e1;
    }

    /* Leave allowance RAG pills */
    .leave-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 3.2rem;
      padding: 0.1rem 0.45rem;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid transparent;
      white-space: nowrap;
    }
    .leave-green {
      background: #dcfce7;
      border-color: #22c55e;
      color: #166534;
    }
    .leave-amber {
      background: #fef9c3;
      border-color: #facc15;
      color: #854d0e;
    }
    .leave-red {
      background: #fee2e2;
      border-color: #ef4444;
      color: #991b1b;
    }

    /* Highlight current day column: soft blue ring around inputs */
    .today-col input {
      box-shadow: 0 0 0 2px #93c5fd;
      border-color: #3b82f6;
    }

    /* ===== Mobile-optimised roster table ===== */
    @media (max-width: 768px) {
      .roster-grid {
        max-height: 65vh;
        overflow-x: auto;
        overflow-y: auto;
      }

      .roster-grid table.roster-table th,
      .roster-grid table.roster-table td {
        padding: 0.15rem 0.2rem;
        font-size: 0.7rem;
      }

      .roster-grid table.roster-table input.shift-input {
        font-size: 0.7rem;
        padding: 0.2rem 0.25rem;
      }

      .roster-grid table.roster-table {
        table-layout: fixed;
      }

      .roster-grid table.roster-table th:nth-child(1),
      .roster-grid table.roster-table td:nth-child(1) {
        width: 110px;
      }

      .roster-grid table.roster-table th:nth-child(2),
      .roster-grid table.roster-table th:nth-child(3),
      .roster-grid table.roster-table th:nth-child(4),
      .roster-grid table.roster-table th:nth-child(5),
      .roster-grid table.roster-table th:nth-child(6),
      .roster-grid table.roster-table th:nth-child(7),
      .roster-grid table.roster-table th:nth-child(8),
      .roster-grid table.roster-table td:nth-child(2),
      .roster-grid table.roster-table td:nth-child(3),
      .roster-grid table.roster-table td:nth-child(4),
      .roster-grid table.roster-table td:nth-child(5),
      .roster-grid table.roster-table td:nth-child(6),
      .roster-grid table.roster-table td:nth-child(7),
      .roster-grid table.roster-table td:nth-child(8) {
        width: 52px;
      }

      .roster-grid table.roster-table th:nth-child(9),
      .roster-grid table.roster-table td:nth-child(9) {
        display: none;
      }
    }

    /* Leave details expansion */
    .leave-toggle {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 0.8rem;
      padding: 0;
      margin-right: 0.25rem;
    }
    .leave-detail-row td {
      text-align: left;
      font-size: 0.75rem;
      background: #edf0f5;
    }
    .leave-detail-block h4 {
      margin: 0.1rem 0;
      font-size: 0.78rem;
    }
    .leave-detail-block ul {
      margin: 0.1rem 0 0.4rem 1rem;
      padding: 0;
    }

    /* ===== Roster weeks hierarchy ===== */
    .weeks-year-row td {
      background: #e5e7eb;
      font-weight: 600;
      text-align: left;
      font-size: 0.85rem;
    }

    .weeks-month-row td {
      background: #f3f4f6;
      text-align: left;
      padding-left: 1.75rem;
      font-weight: 500;
      font-size: 0.8rem;
    }

    .weeks-week-row td {
      background: #ffffff;
    }

    .weeks-toggle {
      border: none;
      background: transparent;
      cursor: pointer;
      margin-right: 0.35rem;
      font-size: 0.8rem;
    }

    .weeks-year-row.collapsed td,
    .weeks-month-row.collapsed td {
      opacity: 0.85;
    }

    /* Print styling */
    @media print {
      body {
        background: #ffffff;
      }
      .no-print {
        display: none !important;
      }
      header {
        display: none !important;
      }
      #editor-card {
        border: none;
        box-shadow: none;
        padding: 0;
        margin: 0;
      }
      .container {
        padding: 0;
        margin: 0;
      }
      .roster-grid {
        max-height: none;
        overflow: visible;
        border: none;
        padding: 0;
        background: #ffffff;
      }
      table {
        page-break-inside: avoid;
      }
    }
  
    /* LBB mismatch badge (subtle, no drama) */
    .lbb-missing-badge{
      display:none;
      margin-left: .5rem;
      padding: .15rem .45rem;
      border-radius: 999px;
      font-size: .75rem;
      font-weight: 700;
      border: 1px solid rgba(0,0,0,.15);
      background: #fbbf24; /* warm amber */
      color: #111827;
      white-space: nowrap;
      cursor: pointer;
      user-select: none;
    }
    .lbb-missing-badge.is-on{ display:inline-flex; align-items:center; gap:.35rem; }

</style>
</head>
<body>
 <header class="no-print">
  <div>
    <h1>Control Roster</h1>
    <span>GitHub-hosted â€¢ Supabase-backed â€¢ Excel finally retired</span>
  </div>
  <div class="flex">
    <span id="user-info" class="muted">Not signed in</span>
    <button id="btn-signout" class="btn btn-sm hidden">Sign out</button>
    <a href="template-admin.html" id="link-template-admin" class="btn btn-sm hidden">Template admin</a>
    <a href="https://control-rosters.vercel.app/LBB.html"
   class="btn btn-sm"
   title="Open Little Black Book">
  ðŸ““ Little Black Book
</a>
  </div>
</header>

  <div class="container">

    <!-- Auth card -->
    <div id="auth-card" class="card no-print">
      <h2>Sign in</h2>
      <p class="muted">Use your Supabase email/password account to manage rosters.</p>
      <form id="auth-form" class="flex mt-2">
        <input type="email" id="auth-email" placeholder="Email" required />
        <input type="password" id="auth-password" placeholder="Password" required />
        <button type="submit" class="btn btn-primary">Sign in</button>
      </form>
      <div class="mt-2">
        <button id="btn-viewer" class="btn btn-sm">
          View roster read-only
        </button>
      </div>
      <p id="auth-error" class="muted mt-2"></p>
    </div>

    <!-- Main app -->
    <div id="app" class="hidden">

      <!-- Week list -->
      <div class="card no-print">
        <div class="flex-between">
  <div>
    <h2>Roster weeks</h2>
    <p class="muted">Draft & published rosters, one record per week ending.</p>
  </div>
  <div class="flex">
    <label class="muted" style="font-size:0.75rem;display:flex;align-items:center;gap:0.25rem;">
      Link:
      <select id="link-selector">
        <option value="CTRL">Control</option>
        <option value="SNDM">SNDM</option>
      </select>
    </label>
    <input type="date" id="new-week-date" />
    <select id="new-week-template">
      <option value="">Templateâ€¦</option>
    </select>
    <button id="btn-create-week" class="btn btn-primary">New draft from template</button>
  </div>
</div>
        <div class="mt-2 table-scroll-x">
          <table id="weeks-table">
            <thead>
              <tr>
                <th>Week ending</th>
                <th>Label</th>
                <th>Status</th>
                <th>Template</th>
                <th>Coverage</th>
                <th>Published at</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="weeks-tbody"></tbody>
          </table>
        </div>
      </div>

      <!-- Analytics card -->
      <div id="analytics-card" class="card no-print">
        <div class="flex-between">
          <div>
            <h2>Analytics</h2>
            <p class="muted">
              Annual totals for RDW, leave, sickness & uncovered shifts across all links.
            </p>
          </div>
          <div class="flex">
            <select id="analytics-year"></select>
            <button id="btn-refresh-analytics" class="btn btn-sm">Refresh</button>
            <button id="btn-toggle-analytics" class="btn btn-sm">Show</button>
          </div>
        </div>

        <div id="analytics-body">
          <!-- Weekly trends -->
          <div class="mt-2">
            <h3 style="margin:0 0 0.25rem;font-size:0.9rem;color:#0f172a;">Weekly trends</h3>
            <p class="muted mb-1">One row per roster week in the selected calendar year.</p>
            <table>
              <thead>
                <tr>
                  <th>Week ending</th>
                  <th>A/L days</th>
                  <th>C/L days</th>
                  <th>Sick days</th>
                  <th>RDW (all)</th>
                  <th>RDW (Sun)</th>
                  <th>Uncovered shifts</th>
                </tr>
              </thead>
              <tbody id="analytics-weekly-tbody"></tbody>
            </table>
          </div>

          <!-- Per-person usage -->
          <div class="mt-3">
            <h3 style="margin:0 0 0.25rem;font-size:0.9rem;color:#0f172a;">Per-person usage</h3>
            <div class="flex-between mb-1">
              <p class="muted mb-1">
                Calendar year totals per staff member (based on roster data).
              </p>
              <input
                id="usage-filter"
                type="text"
                placeholder="Filter by nameâ€¦"
                style="max-width: 220px;"
              />
            </div>
            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>A/L days</th>
                  <th>C/L days</th>
                  <th>RDW (all)</th>
                  <th>RDW (Sun)</th>
                </tr>
              </thead>
              <tbody id="analytics-usage-tbody"></tbody>
            </table>
          </div>

          <!-- Leave allowances -->
          <div class="mt-3">
            <h3 style="margin:0 0 0.25rem;font-size:0.9rem;color:#0f172a;">Leave allowances</h3>
            <p class="muted mb-1">
              A/L uses a fixed annual allowance. C/L allowance is a live bank of usable LROP-earned days
              (12-month validity, minus days already taken).
            </p>
            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>A/L used</th>
                  <th>A/L allowance</th>
                  <th>A/L %</th>
                  <th>
                    C/L used<br/>
                    <span class="muted" style="font-size:0.7rem;">(used in last 12 months)</span>
                  </th>
                  <th>
                    C/L usable balance<br/>
                    <span class="muted" style="font-size:0.7rem;">(valid, unspent credits)</span>
                  </th>
                </tr>
              </thead>
              <tbody id="analytics-leave-tbody"></tbody>
            </table>
            <div class="mt-1 flex-between">
              <button id="btn-save-allowances" class="btn btn-sm">Save leave allowances</button>
              <span id="leave-save-status" class="muted"></span>
            </div>
          </div>

          <!-- Comp leave expiry watch -->
          <div class="mt-3">
            <h3 style="margin:0 0 0.25rem;font-size:0.9rem;color:#0f172a;">Comp leave expiry watch</h3>
            <p class="muted mb-1">
              LROP-earned C/L credits that will expire in the next 60 days (1-year validity from date earned).
            </p>
            <table>
              <thead>
                <tr>
                  <th>Name</th>
<th>Credits expiring</th>
<th>First expiry date</th>
<th>Earned on</th>
                </tr>
              </thead>
              <tbody id="analytics-expiry-tbody"></tbody>
            </table>
          </div>
        </div>
</div>

      <!-- Shift market -->
      <div id="shift-market-card" class="card no-print">
        <div class="flex-between">
          <div>
            <h2>Shift market</h2>
            <p class="muted">
              Uncovered published shifts from the current week onwards. Staff can register interest;
              rankings are based on RDW usage (Sunday RDW if the shift is on a Sunday).
            </p>
          </div>
          <div class="flex">
            <button id="btn-toggle-shift-market" class="btn btn-sm">Show</button>
          </div>
        </div>
        <div id="shift-market-body" class="hidden mt-2">
          <p class="muted mb-1">
            Each row is an uncovered slot from a published roster. Use the selector to register interest
            against your name. Rankings are not an allocation decision, just a transparent view.
          </p>
         <div class="table-scroll-x">
  <table>
    <thead>
      <tr>
        <th>Status</th>
        <th>Week ending</th>
        <th>Date</th>
        <th>Section</th>
        <th>Shift</th>
        <th>Interest</th>
        <th>Peterâ€™s Notebook</th>
      </tr>
    </thead>
    <tbody id="shift-market-tbody"></tbody>
  </table>
</div>
        </div>
      </div>

      <!-- Roster editor -->
      <div id="editor-card" class="card">
        <div class="flex-between">
          <div>
            <h2 id="editor-title">Week editor</h2>
            <p id="editor-subtitle" class="muted"></p>
          </div>
         <div class="flex no-print">
  <span id="editor-status-pill" class="status-pill"></span>
  <button id="btn-save-week" class="btn btn-primary btn-sm">Save draft</button>
  <button id="btn-publish-week" class="btn btn-sm">Publish</button>
  <button id="btn-sync-lbb" class="btn btn-sm" title="Apply approved A/L, C/L and N/A from Little Black Book to this roster week">Sync LBB leave</button>
  <span id="lbb-missing-badge" class="lbb-missing-badge" title="LBB-approved A/L or C/L not tagged in this published week"></span>
  <button id="btn-change-log" class="btn btn-sm">Change log</button>
  <label class="muted" style="display:flex;align-items:center;gap:0.25rem;font-size:0.75rem;">
    <input type="checkbox" id="toggle-readonly" />
    Read-only
  </label>
  <button id="btn-print-week" class="btn btn-sm">Print / PDF</button>
</div>
        </div>
        <!-- Per-week roster filter -->
        <div class="mt-2 no-print" style="max-width:260px;">
          <input
            id="roster-filter"
            type="text"
            placeholder="Filter this week by nameâ€¦"
            style="width:100%;"
          />
        </div>

        <!-- Coverage / legend panel -->
        <div id="coverage-banner" class="coverage-panel mt-1">
          <div class="coverage-top-row">
            <span id="coverage-pill" class="coverage-pill">
              Coverage: n/a
            </span>
            <span id="coverage-summary" class="coverage-summary-text">
              No metrics available yet.
            </span>
          </div>
          <div class="coverage-legend">
            <span class="legend-item">
              <span class="legend-swatch" style="background:#f1a983;"></span> Day
            </span>
            <span class="legend-item">
              <span class="legend-swatch" style="background:#4d93d9;"></span> Night
            </span>
            <span class="legend-item">
              <span class="legend-swatch" style="background:#d86dcd;"></span> Spare
            </span>
            <span class="legend-item">
              <span class="legend-swatch" style="background:#ff0000;"></span> A/L &amp; B.O
            </span>
            <span class="legend-item">
              <span class="legend-swatch" style="background:#4d7c0f;"></span> Sick
            </span>
            <span class="legend-item">
              <span class="legend-swatch" style="background:#f3f4f6;"></span> RD
            </span>
          </div>
        </div>

        <!-- Tag tray (admin only) -->
        <div id="tag-tray" class="mt-2 no-print flex" style="align-items:center;flex-wrap:wrap;">
          <span class="muted" style="font-size:0.75rem;">Tag mode:</span>
<button type="button" id="btn-award-shift" class="btn btn-sm">Award shift</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="RDW">RDW</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="AL">A/L</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="CL">C/L</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="LROP">LROP</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="HROP">HROP</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="BO">B.O</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="SICK">Sick</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="HGD">HGD</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="CLEAR">Clear tags</button>
        </div>

        <div class="mt-2 roster-grid" id="roster-grid"></div>
      </div>
    </div>
  </div>

  <!-- Shared shift presets -->
  <datalist id="shift-presets">
    <option value="0600-1800"></option>
    <option value="0700-1900"></option>
    <option value="0630-1830"></option>
    <option value="1800-0600"></option>
    <option value="1830-0630"></option>
  </datalist>

  <script>
(() => {
    // ===== CONFIG =====
    const SUPABASE_URL = "https://ywvbxfitzsuyhvxcdnth.supabase.co";
    const SUPABASE_ANON_KEY =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl3dmJ4Zml0enN1eWh2eGNkbnRoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMyMzAwNTMsImV4cCI6MjA3ODgwNjA1M30.d-yN2C599j4BInhVt6QKDImhGGmiidIlOjuxAAnjVCM";

    const { createClient } = window.supabase;

     // Reuse client if script is evaluated more than once
  window.__sbClient = window.__sbClient || createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  const supabase = window.__sbClient;

    let currentUser = null;
    let currentProfile = null;
    let currentWeek = null;
    let isPublicViewer = false;
    let forceReadOnly = false;
    let currentLink = "CTRL";

    let lastUsageStats = [];
    let currentAnalyticsYear = null;

    let leaveAllowancesByName = {};
    const COMP_EXPIRY_HORIZON_DAYS = 60;

    // Active tag from the tray (e.g. "AL", "RDW", "CLEAR")
    let activeTag = null;

// ===== Award Shift mode =====
let awardMode = false;
let selectedUncovered = null; // { weekId, sectionId, dayKey, slot }

    // Tracks whether current roster has unsaved edits
    let hasUnsavedChanges = false;

    // ===== Date helpers =====
    function formatUK(dateStr) {
      if (!dateStr) return "";
      const d = new Date(dateStr);
      if (isNaN(d)) return dateStr;
      const day = String(d.getDate()).padStart(2, "0");
      const month = String(d.getMonth() + 1).padStart(2, "0");
      const year = d.getFullYear();
      return `${day}/${month}/${year}`;
    }

    function addDays(date, days) {
      const d = new Date(date.getTime());
      d.setDate(d.getDate() + days);
      return d;
    }

    function isEffectiveReadOnly() {
  const role = currentProfile?.role || "viewer";

  // Editor is read-only on draft weeks
  const isEditorLocked =
    role === "editor" &&
    currentWeek &&
    currentWeek.status === "draft";

  return (
    isPublicViewer ||
    role === "viewer" ||
    forceReadOnly ||
    isEditorLocked
  );
}

function canManageRoster() {
  const role = currentProfile?.role || "viewer";
  return !isPublicViewer && !forceReadOnly && (role === "admin" || role === "editor");
}

    // Given week-ending date and day key, get actual Date (week ending = Saturday)
    function getDateForDay(weekEndingStr, dayKey) {
      if (!weekEndingStr) return null;
      const end = new Date(weekEndingStr);
      if (isNaN(end)) return null;
      const offsets = {
        sun: -6,
        mon: -5,
        tue: -4,
        wed: -3,
        thu: -2,
        fri: -1,
        sat: 0
      };
      const offset = offsets[dayKey] ?? 0;
      const d = new Date(end.getTime());
      d.setDate(d.getDate() + offset);
      return d;
    }

    // ===== DOM HOOKS =====
    const authCard = document.getElementById("auth-card");
    const appEl = document.getElementById("app");
    const authForm = document.getElementById("auth-form");
    const authEmail = document.getElementById("auth-email");
    const authPassword = document.getElementById("auth-password");
    const authError = document.getElementById("auth-error");
    const userInfo = document.getElementById("user-info");
    const btnSignout = document.getElementById("btn-signout");
    const btnViewer = document.getElementById("btn-viewer");

    const newWeekTemplateSelect = document.getElementById("new-week-template");
    const weeksTbody = document.getElementById("weeks-tbody");
    const linkSelector = document.getElementById("link-selector");

    if (linkSelector) {
      linkSelector.addEventListener("change", async () => {
        if (!confirmDiscardChanges()) {
          // revert selector if user cancels
          linkSelector.value = currentLink;
          return;
        }
        currentLink = linkSelector.value || "CTRL";
        currentWeek = null;
        editorCard.classList.add("hidden");
        hasUnsavedChanges = false;

        await loadTemplates();
        await loadWeeks();
        await loadAnalyticsYears();
        await refreshAnalytics();
        await refreshExpiryWatch();
        await refreshShiftMarket();
      });
    }

    const newWeekDate = document.getElementById("new-week-date");
    const btnCreateWeek = document.getElementById("btn-create-week");

    const editorCard = document.getElementById("editor-card");
    const editorTitle = document.getElementById("editor-title");
    const editorSubtitle = document.getElementById("editor-subtitle");
    const editorStatusPill = document.getElementById("editor-status-pill");
    const rosterGrid = document.getElementById("roster-grid");
    const btnSaveWeek = document.getElementById("btn-save-week");
    const btnPublishWeek = document.getElementById("btn-publish-week");
    const btnSyncLBB = document.getElementById("btn-sync-lbb");
    
    const lbbMissingBadge = document.getElementById("lbb-missing-badge");
const btnPrintWeek = document.getElementById("btn-print-week");
    const readonlyToggle = document.getElementById("toggle-readonly");
    const rosterFilterInput = document.getElementById("roster-filter");
const btnChangeLog = document.getElementById("btn-change-log");


    const analyticsYearSelect = document.getElementById("analytics-year");
    const btnRefreshAnalytics = document.getElementById("btn-refresh-analytics");
    const btnToggleAnalytics = document.getElementById("btn-toggle-analytics");
    const analyticsBody = document.getElementById("analytics-body");
    const analyticsWeeklyTbody = document.getElementById("analytics-weekly-tbody");
    const analyticsUsageTbody = document.getElementById("analytics-usage-tbody");
    const analyticsLeaveTbody = document.getElementById("analytics-leave-tbody");
    const analyticsExpiryTbody = document.getElementById("analytics-expiry-tbody");
    const usageFilterInput = document.getElementById("usage-filter");
    const btnSaveAllowances = document.getElementById("btn-save-allowances");
    const leaveSaveStatus = document.getElementById("leave-save-status");

    const coveragePill = document.getElementById("coverage-pill");
    const coverageSummary = document.getElementById("coverage-summary");

    const tagTray = document.getElementById("tag-tray");

const btnAwardShift = document.getElementById("btn-award-shift");

function setAwardMode(on) {
  awardMode = !!on;
  selectedUncovered = null;

  if (btnAwardShift) {
    btnAwardShift.classList.toggle("tag-tray-btn-active", awardMode);
    btnAwardShift.textContent = awardMode ? "Award shift: ON" : "Award shift";
  }
}

if (btnAwardShift) {
  btnAwardShift.addEventListener("click", () => {
    if (!canManageRoster()) {
      alert("Awarding shifts is only available to Admin/Editor (not read-only).");
      return;
    }

    // Turn off tag mode when award mode turns on
    if (!awardMode) {
      activeTag = null;
      tagTray.querySelectorAll(".tag-tray-btn").forEach(b => b.classList.remove("tag-tray-btn-active"));
    }

    setAwardMode(!awardMode);
  });
}

    const shiftMarketCard = document.getElementById("shift-market-card");
    const shiftMarketBody = document.getElementById("shift-market-body");
    const shiftMarketTbody = document.getElementById("shift-market-tbody");
    const btnToggleShiftMarket = document.getElementById("btn-toggle-shift-market");

    function syncTagTrayVisibility() {
      if (!tagTray) return;
      tagTray.style.display = isEffectiveReadOnly() ? "none" : "flex";
    }

    if (readonlyToggle) {
      readonlyToggle.addEventListener("change", () => {
        forceReadOnly = !!readonlyToggle.checked;
        syncTagTrayVisibility();
        if (currentWeek) {
          renderRosterGrid(currentWeek.data);
          runPostRenderChecks();
          }
      });
    }

    // Default analytics collapsed
    analyticsBody.classList.add("hidden");
    btnToggleAnalytics.textContent = "Show";

    // Default shift market collapsed
    if (shiftMarketBody && btnToggleShiftMarket) {
      shiftMarketBody.classList.add("hidden");
      btnToggleShiftMarket.textContent = "Show";
      btnToggleShiftMarket.addEventListener("click", () => {
        const collapsed = shiftMarketBody.classList.toggle("hidden");
        btnToggleShiftMarket.textContent = collapsed ? "Show" : "Hide";
      });
    }

    // ===== AUTH =====
    authForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      authError.textContent = "";
      const email = authEmail.value.trim();
      const password = authPassword.value;

      const { data, error } = await supabase.auth.signInWithPassword({ email, password });
      if (error) {
        authError.textContent = error.message;
        return;
      }
      currentUser = data.user;
      isPublicViewer = false;
      await loadProfile();
      await postLoginInit();
    });

      btnSignout.addEventListener("click", async () => {
      if (!confirmDiscardChanges()) return;

      await supabase.auth.signOut();
      currentUser = null;
      currentProfile = null;
      currentWeek = null;
      isPublicViewer = false;
      userInfo.textContent = "Not signed in";
      btnSignout.classList.add("hidden");
      authCard.classList.remove("hidden");
      appEl.classList.add("hidden");
      editorCard.classList.add("hidden");
    });

        btnViewer.addEventListener("click", async (e) => {
      e.preventDefault();

      if (!confirmDiscardChanges()) return;

      isPublicViewer = true;
      currentUser = null;
      currentProfile = { full_name: "Public viewer", role: "viewer" };

      userInfo.textContent = "Public viewer â€¢ read-only";
      btnSignout.classList.add("hidden");
      authCard.classList.add("hidden");
      appEl.classList.remove("hidden");

      newWeekDate.disabled = true;
      newWeekTemplateSelect.disabled = true;
      btnCreateWeek.disabled = true;

      syncTagTrayVisibility();

      await loadTemplates();
      await loadWeeks();
      await loadAnalyticsYears();
      await refreshAnalytics();
      await refreshExpiryWatch();
      await refreshShiftMarket();
    });

    async function loadProfile() {
      if (!currentUser) return;
      const { data, error } = await supabase
        .from("profiles")
        .select("*")
        .eq("id", currentUser.id)
        .single();

      if (!error) currentProfile = data;
    }

    async function postLoginInit() {
  const role = currentProfile?.role || "viewer";

  userInfo.textContent = currentProfile
    ? `${currentProfile.full_name || currentUser.email} â€¢ ${currentProfile.role}`
    : currentUser.email;

  isPublicViewer = false;
  btnSignout.classList.remove("hidden");

  // âœ… Show / hide Template Admin link based on role
  const templateAdminLink = document.getElementById("link-template-admin");
  if (templateAdminLink) {
    if (role === "admin") {
      templateAdminLink.classList.remove("hidden");
    } else {
      templateAdminLink.classList.add("hidden");
    }
  }

  authCard.classList.add("hidden");
  appEl.classList.remove("hidden");

  newWeekDate.disabled = false;
  newWeekTemplateSelect.disabled = false;
 btnCreateWeek.disabled = !(role === "admin");

  syncTagTrayVisibility();

  await loadTemplates();
  await loadWeeks();
  await loadAnalyticsYears();
  await refreshAnalytics();
  await refreshExpiryWatch();
  await refreshShiftMarket();
}

    (async function init() {
      const { data } = await supabase.auth.getSession();
      if (data.session) {
        currentUser = data.session.user;
        await loadProfile();
        await postLoginInit();
      } else {
        syncTagTrayVisibility();
      }
    })();

    // Tag tray behaviour
    if (tagTray) {
      const trayButtons = tagTray.querySelectorAll(".tag-tray-btn");
      trayButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          if (isEffectiveReadOnly()) return;
          const tag = btn.dataset.tag || null;
          if (activeTag === tag) {
            activeTag = null;
            trayButtons.forEach((b) => b.classList.remove("tag-tray-btn-active"));
          } else {
            activeTag = tag;
            trayButtons.forEach((b) => b.classList.remove("tag-tray-btn-active"));
            btn.classList.add("tag-tray-btn-active");
          }
        });
      });
    }

    // ===== TEMPLATES =====
    async function loadTemplates() {
            const { data, error } = await supabase
        .from("roster_templates")
        .select("id, name, code")
        .eq("link", currentLink)
        .order("code", { ascending: true });

      if (error) {
        console.error("loadTemplates error", error);
        return;
      }

      newWeekTemplateSelect.innerHTML = '<option value="">Templateâ€¦</option>';
      for (const t of data) {
        const opt = document.createElement("option");
        opt.value = t.id;
        opt.textContent = `${t.code} â€“ ${t.name}`;
        newWeekTemplateSelect.appendChild(opt);
      }
    }

    btnCreateWeek.addEventListener("click", async () => {
      if (!confirmDiscardChanges()) return;

      const role = currentProfile?.role || "viewer";
if (isPublicViewer || role !== "admin") {
  alert("You do not have permission to create weeks.");
  return;
}

      const dateStr = newWeekDate.value;
      const templateId = newWeekTemplateSelect.value;
      if (!dateStr || !templateId) {
        alert("Pick a week ending date and a template.");
        return;
      }

      const { data: tmpl, error: tmplErr } = await supabase
        .from("roster_templates")
        .select("id, name, code, structure")
        .eq("id", templateId)
        .single();

      if (tmplErr) {
        console.error(tmplErr);
        alert("Unable to load template.");
        return;
      }

      const label = `Week - Ending ${formatUK(dateStr)}`;
            const payload = {
        week_ending: dateStr,
        label,
        status: "draft",
        template_id: tmpl.id,
        data: tmpl.structure,
        link: currentLink
      };

      const { data, error } = await supabase
        .from("roster_weeks")
        .insert(payload)
        .select("*")
        .single();

      if (error) {
        console.error(error);
        alert("Error creating week.");
        return;
      }

      await loadWeeks();
      await openWeek(data);
      await loadAnalyticsYears();
      await refreshAnalytics();
      await refreshExpiryWatch();
    });

    // ===== WEEK LIST =====
       async function loadWeeks() {
            const { data, error } = await supabase
        .from("roster_weeks")
        .select(
          "id, week_ending, label, status, template_id, created_at, published_at, data, roster_templates(name, code)"
        )
        .eq("link", currentLink)
        .order("week_ending", { ascending: false });

      if (error) {
        console.error("loadWeeks error", error);
        return;
      }

      weeksTbody.innerHTML = "";
      if (!data || !data.length) return;

      // Group weeks -> year -> month
      const groups = {};
      data.forEach((w) => {
        if (!w.week_ending) return;
        const d = new Date(w.week_ending);
        if (isNaN(d)) return;
        const year = d.getFullYear();
        const monthIdx = d.getMonth(); // 0-11

        if (!groups[year]) groups[year] = {};
        if (!groups[year][monthIdx]) groups[year][monthIdx] = [];
        groups[year][monthIdx].push(w);
      });

      const today = new Date();
      const currentYearNum = today.getFullYear();
      const currentMonthNum = today.getMonth(); // 0-11

      const sortedYears = Object.keys(groups)
        .map(Number)
        .sort((a, b) => b - a); // latest year first

      sortedYears.forEach((year) => {
        // ==== Year row ====
        const yearTr = document.createElement("tr");
        yearTr.className = "weeks-year-row";
        yearTr.dataset.year = String(year);

        const yearTd = document.createElement("td");
        yearTd.colSpan = 7;
        yearTd.innerHTML = `
          <button
            type="button"
            class="weeks-toggle"
            data-level="year"
            data-year="${year}"
          >
            â–¼
          </button>
          <strong>${year}</strong>
        `;
        yearTr.appendChild(yearTd);
        weeksTbody.appendChild(yearTr);

        // ==== Month rows ====
        const monthsObj = groups[year];
        const sortedMonths = Object.keys(monthsObj)
          .map(Number)
          .sort((a, b) => b - a); // latest month first

        sortedMonths.forEach((monthIdx) => {
          const monthName = new Date(year, monthIdx, 1).toLocaleString("en-GB", {
            month: "long",
          });

          const monthTr = document.createElement("tr");
          monthTr.className = "weeks-month-row";
          monthTr.dataset.year = String(year);
          monthTr.dataset.month = String(monthIdx);

          const monthTd = document.createElement("td");
          monthTd.colSpan = 7;
          monthTd.innerHTML = `
            <button
              type="button"
              class="weeks-toggle"
              data-level="month"
              data-year="${year}"
              data-month="${monthIdx}"
            >
              â–¼
            </button>
            <span>${monthName}</span>
          `;
          monthTr.appendChild(monthTd);
          weeksTbody.appendChild(monthTr);

          // ==== Week rows ====
          monthsObj[monthIdx].forEach((w) => {
            const tr = document.createElement("tr");
            tr.className = "weeks-week-row";
            tr.dataset.year = String(year);
            tr.dataset.month = String(monthIdx);

            const tmplLabel = w.roster_templates
              ? `${w.roster_templates.code} â€“ ${w.roster_templates.name}`
              : "N/A";

            const metrics = computeWeekMetrics(w);
            const hasGaps = metrics.uncovered > 0;

            const coverageCell = hasGaps
              ? `<span class="tag" style="border-color:#fbbf24;background:#fef9c3;color:#92400e;">âš  Gaps</span>`
              : `<span class="tag" style="border-color:#22c55e;background:#ecfdf3;color:#166534;">âœ… Full</span>`;

            tr.innerHTML = `
              <td>${formatUK(w.week_ending)}</td>
              <td>${w.label || ""}</td>
              <td>
                <span class="status-pill ${
                  w.status === "published" ? "status-published" : "status-draft"
                }">
                  ${w.status}
                </span>
              </td>
              <td>${tmplLabel}</td>
              <td>${coverageCell}</td>
              <td>${w.published_at ? formatUK(w.published_at) : ""}</td>
              <td>
                <button class="btn btn-sm btn-open-week" data-id="${w.id}">Open</button>
              </td>
            `;
            weeksTbody.appendChild(tr);
          });
        });
      });

      // Wire up the "Open" buttons as before
      document.querySelectorAll(".btn-open-week").forEach((btn) => {
        btn.addEventListener("click", async () => {
          if (!confirmDiscardChanges()) return;

          const id = btn.getAttribute("data-id");
          const { data, error } = await supabase
            .from("roster_weeks")
            .select("*")
            .eq("id", id)
            .single();

          if (error) {
            console.error(error);
            return;
          }
          await openWeek(data);
        });
      });

      // Apply initial collapse state & wire toggles
      applyInitialWeekCollapse(currentYearNum, currentMonthNum);
      wireWeekToggleHandlers();
    }

    function collapseYear(year) {
      const yStr = String(year);
      const yearRow = weeksTbody.querySelector(
        `.weeks-year-row[data-year="${yStr}"]`
      );
      if (yearRow) yearRow.classList.add("collapsed");

      // Hide months + weeks for this year
      weeksTbody
        .querySelectorAll(
          `.weeks-month-row[data-year="${yStr}"], .weeks-week-row[data-year="${yStr}"]`
        )
        .forEach((row) => {
          row.style.display = "none";
        });

      const btn = weeksTbody.querySelector(
        `.weeks-toggle[data-level="year"][data-year="${yStr}"]`
      );
      if (btn) btn.textContent = "â–¶";
      return true;
    }

    function expandYear(year) {
      const yStr = String(year);
      const yearRow = weeksTbody.querySelector(
        `.weeks-year-row[data-year="${yStr}"]`
      );
      if (yearRow) yearRow.classList.remove("collapsed");

      // Show month headers; week rows controlled by their month collapse state
      weeksTbody
        .querySelectorAll(`.weeks-month-row[data-year="${yStr}"]`)
        .forEach((row) => {
          row.style.display = "";
        });

      const btn = weeksTbody.querySelector(
        `.weeks-toggle[data-level="year"][data-year="${yStr}"]`
      );
      if (btn) btn.textContent = "â–¼";
      return false;
    }

    function toggleYear(year) {
      const yStr = String(year);
      const yearRow = weeksTbody.querySelector(
        `.weeks-year-row[data-year="${yStr}"]`
      );
      const collapsed = yearRow?.classList.contains("collapsed");
      if (collapsed) {
        return expandYear(year);
      } else {
        return collapseYear(year);
      }
    }

    function collapseMonth(year, monthIdx) {
      const yStr = String(year);
      const mStr = String(monthIdx);
      const monthRow = weeksTbody.querySelector(
        `.weeks-month-row[data-year="${yStr}"][data-month="${mStr}"]`
      );
      if (monthRow) monthRow.classList.add("collapsed");

      weeksTbody
        .querySelectorAll(
          `.weeks-week-row[data-year="${yStr}"][data-month="${mStr}"]`
        )
        .forEach((row) => {
          row.style.display = "none";
        });

      const btn = weeksTbody.querySelector(
        `.weeks-toggle[data-level="month"][data-year="${yStr}"][data-month="${mStr}"]`
      );
      if (btn) btn.textContent = "â–¶";
      return true;
    }

    function expandMonth(year, monthIdx) {
      const yStr = String(year);
      const mStr = String(monthIdx);
      const monthRow = weeksTbody.querySelector(
        `.weeks-month-row[data-year="${yStr}"][data-month="${mStr}"]`
      );
      if (monthRow) monthRow.classList.remove("collapsed");

      weeksTbody
        .querySelectorAll(
          `.weeks-week-row[data-year="${yStr}"][data-month="${mStr}"]`
        )
        .forEach((row) => {
          row.style.display = "";
        });

      const btn = weeksTbody.querySelector(
        `.weeks-toggle[data-level="month"][data-year="${yStr}"][data-month="${mStr}"]`
      );
      if (btn) btn.textContent = "â–¼";
      return false;
    }

    function toggleMonth(year, monthIdx) {
      const yStr = String(year);
      const mStr = String(monthIdx);
      const monthRow = weeksTbody.querySelector(
        `.weeks-month-row[data-year="${yStr}"][data-month="${mStr}"]`
      );
      const collapsed = monthRow?.classList.contains("collapsed");
      if (collapsed) {
        return expandMonth(year, monthIdx);
      } else {
        return collapseMonth(year, monthIdx);
      }
    }

function shouldAutoExpandMonth(year, monthIdx) {
  const now = new Date();
  const curKey = now.getFullYear() * 12 + now.getMonth();
  const nextKey = curKey + 1;

  const targetKey = year * 12 + monthIdx;
  return targetKey === curKey || targetKey === nextKey;
}

    function applyInitialWeekCollapse(currentYear, currentMonth) {
  // Default: everything visible
  weeksTbody
    .querySelectorAll(".weeks-year-row, .weeks-month-row, .weeks-week-row")
    .forEach((row) => {
      row.style.display = "";
    });

  const yearRows = weeksTbody.querySelectorAll(".weeks-year-row");
  yearRows.forEach((yrRow) => {
    const year = Number(yrRow.dataset.year);

    // Collapse all years before current year
    if (year < currentYear) {
      collapseYear(year);
      return;
    }

    // Keep current/future years expanded at year level (so month headers visible)
    expandYear(year);

    const monthRows = weeksTbody.querySelectorAll(
      `.weeks-month-row[data-year="${year}"]`
    );

    monthRows.forEach((mRow) => {
      const monthIdx = Number(mRow.dataset.month);

      // Always show the month header row (itâ€™s the clickable control)
      mRow.style.display = "";

      // Only auto-expand current month + next month. Everything else collapsed.
      if (shouldAutoExpandMonth(year, monthIdx)) {
        expandMonth(year, monthIdx);
      } else {
        collapseMonth(year, monthIdx);
      }
    });
  });
}

    function wireWeekToggleHandlers() {
      weeksTbody.querySelectorAll(".weeks-toggle").forEach((btn) => {
        btn.addEventListener("click", () => {
          const level = btn.dataset.level;
          const year = Number(btn.dataset.year);
          const month =
            btn.dataset.month !== undefined
              ? Number(btn.dataset.month)
              : null;

          if (level === "year") {
            toggleYear(year);
          } else if (level === "month" && month !== null) {
            toggleMonth(year, month);
          }
        });
      });
    }

    // Mark which cells were originally SPARE in the base roster
    function ensureSpareOrigin(struct) {
      if (!struct || !Array.isArray(struct.sections)) return;
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      struct.sections.forEach((section) => {
        (section.rows || []).forEach((row) => {
          if (!row.spare_origin) row.spare_origin = {};
          days.forEach((day) => {
            if (typeof row.spare_origin[day] === "boolean") return;
            const v = (row.shifts && row.shifts[day])
              ? String(row.shifts[day]).toUpperCase()
              : "";
            row.spare_origin[day] = v.includes("SPARE");
          });
        });
      });
    }

    function ensureRowTags(row) {
      if (!row.tags) row.tags = {};
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
      days.forEach((day) => {
        if (!Array.isArray(row.tags[day])) {
          row.tags[day] = [];
        }
      });
    }

    async function openWeek(weekRow) {
      currentWeek = weekRow;
      ensureSpareOrigin(currentWeek.data);

      editorCard.classList.remove("hidden");
      editorTitle.textContent = `Week ending ${formatUK(weekRow.week_ending)}`;
      editorSubtitle.textContent = weekRow.label || "";
      setStatusPill(weekRow.status);
      syncTagTrayVisibility();
      renderRosterGrid(weekRow.data);
      syncEditorButtons();
      updateCoverageBanner();

      // Opening a week is a clean baseline
      hasUnsavedChanges = false;
    }

    function setStatusPill(status) {
      editorStatusPill.textContent = status;
      editorStatusPill.classList.remove("status-draft", "status-published");
      editorStatusPill.classList.add(status === "published" ? "status-published" : "status-draft");
    }

    function syncEditorButtons() {
  const role = currentProfile?.role || "viewer";
  const isAdmin = role === "admin";
  const isEditor = role === "editor";

  if (!currentWeek) {
    btnSaveWeek.disabled = true;
    btnPublishWeek.disabled = true;
    btnPublishWeek.textContent = "Publish";
    return;
  }

  const isDraft = currentWeek.status === "draft";

  // Viewers & public: no controls
  if (isPublicViewer || role === "viewer") {
    btnSaveWeek.disabled = true;
    btnPublishWeek.disabled = true;
    btnPublishWeek.textContent = isDraft ? "Publish" : "Re-publish";
    return;
  }

  if (isDraft) {
    // Draft weeks: only Admin can touch
    btnSaveWeek.disabled = !isAdmin;
    btnPublishWeek.disabled = !isAdmin;
    btnPublishWeek.textContent = "Publish";
    } else {
    // Published weeks:
    // - Admin & Editor can edit and re-publish
    btnSaveWeek.disabled = !(isAdmin || isEditor);
    btnPublishWeek.disabled = !(isAdmin || isEditor);
    btnPublishWeek.textContent = "Re-publish";
  }
}

    // ===== CLASSIFY SHIFTS =====
    function classifyShift(value, tags) {
  const classes = [];
  const v = (value || "").trim().toUpperCase();
  const tagSet = new Set((tags || []).map((t) => String(t).toUpperCase()));

  if (!v && tagSet.size === 0) return "";

  // Base on times / text
  if (v.includes("0600-1800") || v.includes("0700-1900") || v.includes("0630-1830")) {
    classes.push("shift-day");
  }
  if (v.includes("1800-0600") || v.includes("1830-0630")) {
    classes.push("shift-night");
  }
  if (v.includes("SPARE")) {
    classes.push("shift-spare");
  }
  if (v === "N/A") {
    classes.push("shift-oo");
  }
  if (v === "RD") {
    classes.push("shift-rd");
  }

  // Based on tags OR legacy text markers
  const hasAL   = tagSet.has("AL")   || v.includes("A/L");
  const hasCL   = tagSet.has("CL")   || v.includes("C/L");
  const hasSick = tagSet.has("SICK") || v.includes("SICK") || v.includes("S/L");
  const hasBO   = tagSet.has("BO")   || v.includes("B.O");
  const hasRop  = tagSet.has("LROP") || tagSet.has("HROP") || v.includes("LROP") || v.includes("HROP");

  // ðŸ”¹ Only show grey 12+OC styling if it's NOT on AL / CL / SICK / BO
  if (!hasAL && !hasCL && !hasSick && !hasBO && v.includes("12+OC")) {
    classes.push("shift-12oc");
  }

  if (hasAL)   classes.push("shift-al");
  if (hasCL)   classes.push("shift-cl");
  if (hasSick) classes.push("shift-sick");
  if (hasBO)   classes.push("shift-bo");
  if (hasRop)  classes.push("shift-rop");

  return classes.join(" ");
}

    const BLOCKED_MODIFIERS = ["RDW", "A/L", "C/L", "LROP", "HROP", "B.O", "SICK", "HGD"];

    function enforceShiftInputRules(el){
    // Goal: stop people accidentally typing shift modifiers into free-text fields.
    // Old approach used substring regex matches, which hilariously nuked normal words.
    if(!el || typeof el.value!=="string") return;

    const raw = el.value;
    // Split but keep whitespace so we don't smash formatting
    const parts = raw.split(/(\s+)/);

    let hit = false;
    for(let i=0;i<parts.length;i++){
      const p = parts[i];
      if(!p || /^\s+$/.test(p)) continue;

      // Strip common punctuation from edges for matching (so "A/L," still counts)
      const stripped = p.trim().replace(/^[\(\[\{<"']+|[\)\]\}>,"'.;:!?]+$/g, "");
      const norm = stripped.toUpperCase();

      // Direct-match only: token must be exactly a blocked modifier (case-insensitive)
      if(BLOCKED_MODIFIERS.includes(norm)){
        parts[i] = ""; // remove just the token
        hit = true;
      }
    }

    if(hit){
      const cleaned = parts.join("").replace(/[ \t]{2,}/g, " ");
      if(cleaned !== raw){
        el.value = cleaned;
        warnShiftModifierOnce();
      }
    }
  }

  let __lastShiftModifierWarn = 0;
  function warnShiftModifierOnce(){
    const now = Date.now();
    if(now - __lastShiftModifierWarn < 1500) return; // throttle spammy popups
    __lastShiftModifierWarn = now;
    alert(`Shift modifiers (e.g., ${BLOCKED_MODIFIERS.join(", ")}) are controlled by the shift buttons/presets.\n\nIf you meant one of those tags, use the proper selector instead of typing it into free text.`);
  }

    // Ensure uncovered structure supports two slots (s1, s2)
    function ensureUncovered(section) {
      if (!section.uncovered) {
        section.uncovered = {};
      }

      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      days.forEach((day) => {
        const current = section.uncovered[day];

        if (typeof current === "string") {
          section.uncovered[day] = {
            s1: current,
            s2: ""
          };
        } else if (!current || typeof current !== "object") {
          section.uncovered[day] = {
            s1: "",
            s2: ""
          };
        } else {
          section.uncovered[day].s1 = section.uncovered[day].s1 || "";
          section.uncovered[day].s2 = section.uncovered[day].s2 || "";
        }
      });
    }

    // Returns true if the current week-ending date includes today's date
    function weekContainsToday(weekEndingStr) {
      if (!weekEndingStr) return false;
      const end = new Date(weekEndingStr);
      if (isNaN(end)) return false;

      const today = new Date();
      const oneDay = 24 * 60 * 60 * 1000;

      const diffDays = Math.floor((end - today) / oneDay);

      return diffDays >= 0 && diffDays <= 6;
    }

    // Prompt user if they try to leave with unsaved changes
    function confirmDiscardChanges() {
      if (!hasUnsavedChanges) return true;
      return window.confirm("Are you sure you want to leave this roster without saving?");
    }

    // Browser-level guard (tab close / reload / URL change)
    window.addEventListener("beforeunload", (e) => {
      if (!hasUnsavedChanges) return;
      e.preventDefault();
      e.returnValue = "";
    });

    // Apply a tag from the tray to a single cell
    function applyTagToCell(sectionId, rowIndex, dayKey) {
      if (!currentWeek || !activeTag) return;
      if (isEffectiveReadOnly()) return;

      const sections = currentWeek.data.sections || [];
      const section = sections.find((s) => s.id === sectionId);
      if (!section) return;
      if (!section.rows || !section.rows[rowIndex]) return;

      const row = section.rows[rowIndex];
      ensureRowTags(row);

      const tags = row.tags[dayKey] || [];
      const tagUpper = activeTag.toUpperCase();

      // CLEAR mode: remove all tags from this cell + reset RDW flag
      if (tagUpper === "CLEAR") {
        row.tags[dayKey] = [];
        if (row.rdw && Object.prototype.hasOwnProperty.call(row.rdw, dayKey)) {
          row.rdw[dayKey] = false;
        }
      } else {
        const existingIndex = tags.findIndex((t) => String(t).toUpperCase() === tagUpper);
        if (existingIndex >= 0) {
          // Remove tag
          tags.splice(existingIndex, 1);
          row.tags[dayKey] = tags;
          if (tagUpper === "RDW") {
            if (!row.rdw) row.rdw = {};
            row.rdw[dayKey] = false;
          }
        } else {
                   // Add tag
          tags.push(tagUpper);
          row.tags[dayKey] = tags;
          if (tagUpper === "RDW") {
            if (!row.rdw) row.rdw = {};
            row.rdw[dayKey] = true;
          }

          // If A/L or C/L is being added, mirror the existing shift into the uncovered row (unless it's SPARE)
          if (
  tagUpper === "AL" ||
  tagUpper === "CL" ||
  tagUpper === "BO" ||
  tagUpper === "SICK"
) {
            // Make sure the uncovered structure exists for this section/day
            ensureUncovered(section);
            const u = section.uncovered[dayKey];
            const shiftVal =
              row.shifts && row.shifts[dayKey]
                ? String(row.shifts[dayKey])
                : "";
            const upperShift = shiftVal.toUpperCase();

            // Ignore pure spare shifts
            if (shiftVal && !upperShift.includes("SPARE")) {
              if (!u.s1) {
                u.s1 = shiftVal;
              } else if (!u.s2) {
                u.s2 = shiftVal;
              }
            }
          }
        }
      }

 // Mark roster as dirty
      hasUnsavedChanges = true;

      renderRosterGrid(currentWeek.data);
      runPostRenderChecks();
    }

    // ===== ROSTER RENDERING =====
    
    // ===== Little Black Book (calendar) -> Roster tag sync =====
    function isoDate(d){
      const x = new Date(d);
      if (isNaN(x)) return null;
      const y = x.getFullYear();
      const m = String(x.getMonth()+1).padStart(2,"0");
      const da = String(x.getDate()).padStart(2,"0");
      return `${y}-${m}-${da}`;
    }
    function addDays(d, n){
      const x = new Date(d);
      x.setDate(x.getDate() + n);
      return x;
    }
    function datesOverlap(aStart, aEnd, bStart, bEnd){
      return aStart <= bEnd && aEnd >= bStart;
    }
    function ensureRowTagsForSync(row){
      if (!row.tags || typeof row.tags !== "object") row.tags = {};
    }
    function addTagToRowDay(row, dayKey, tag){
      ensureRowTagsForSync(row);
      const up = String(tag||"").toUpperCase();
      if (!up) return;
      const cur = Array.isArray(row.tags[dayKey]) ? row.tags[dayKey] : [];
      const exists = cur.some(t => String(t).toUpperCase() === up);
      if (!exists){
        cur.push(up);
        row.tags[dayKey] = cur;
      }
    }
    function cellAllowsNA(row, dayKey){
      // N/A should only apply to: blank cells, RD cells, or Sundays.
      if (String(dayKey).toLowerCase() === "sun") return true;
      const v = String(row.shifts?.[dayKey] || "").trim().toUpperCase();
      if (!v) return true;
      // Treat any RD-prefixed cell as eligible (RD / RDW / RD (something))
      if (v === "RD" || v.startsWith("RD")) return true;
      return false;
    }

    async function syncLeaveFromLBB(){
      if (!currentWeek || !currentWeek.week_ending || !currentWeek.data){
        alert("Open a roster week first.");
        return;
      }
      if (!supabase){
        alert("Supabase client not initialised.");
        return;
      }

      const end = new Date(currentWeek.week_ending);          // week ending (usually Saturday)
      if (isNaN(end)){
        alert("Week ending date is invalid.");
        return;
      }
      const start = addDays(end, -6);                         // Sunday start
      const startStr = isoDate(start);
      const endStr   = isoDate(end);

      const ok = confirm(
        `Sync approved Little Black Book entries into this roster week?\n\nWeek: ${formatUK(startStr)} to ${formatUK(endStr)}\n\nRules:\nâ€¢ A/L + C/L tags always apply (even if a turn of duty is shown)\nâ€¢ N/A only applies to blank / RD cells, or Sunday\n\nThis updates the open week (draft) only.`
      );
      if (!ok) return;

      // Pull approved calendar entries overlapping this roster week
      const { data: entries, error } = await supabase
        .from("calendar_entries")
        .select("id, start_date, end_date, entry_type, status, staff_directory(canonical_name)")
        .in("status", ["AUTO_APPROVED", "APPROVED"])
        .in("entry_type", ["AL","CL","NA"])
        .lte("start_date", endStr)
        .gte("end_date", startStr);

      if (error){
        console.error(error);
        alert("Failed to pull Little Black Book entries. Check Supabase permissions / table names.");
        return;
      }

      const days = ["sun","mon","tue","wed","thu","fri","sat"];
      const startTime = new Date(startStr + "T00:00:00");
      const endTime   = new Date(endStr   + "T23:59:59");

      let applied = 0;

      const byName = new Map();
      (entries || []).forEach(e=>{
        const name = (e.staff_directory && e.staff_directory.canonical_name) ? String(e.staff_directory.canonical_name).trim() : "";
        if (!name) return;
        if (!byName.has(name)) byName.set(name, []);
        byName.get(name).push(e);
      });

      // Walk roster rows and apply tags where calendar overlap exists
      currentWeek.data.sections.forEach(section=>{
        (section.rows || []).forEach(row=>{
          const name = String(row.staff_name || "").trim();
          if (!name) return;

          const staffEntries = byName.get(name);
          if (!staffEntries || !staffEntries.length) return;

          staffEntries.forEach(e=>{
            const eStart = new Date(String(e.start_date) + "T00:00:00");
            const eEnd   = new Date(String(e.end_date)   + "T23:59:59");
            if (!datesOverlap(eStart, eEnd, startTime, endTime)) return;

            // Apply for each day in the roster week
            for (let i=0;i<7;i++){
              const d = addDays(startTime, i);
              if (d < eStart || d > eEnd) continue;

              const dayKey = days[i];
              const type = String(e.entry_type || "").toUpperCase();

              if (type === "AL" || type === "CL"){
                addTagToRowDay(row, dayKey, type);
                applied++;
              } else if (type === "NA"){
                if (cellAllowsNA(row, dayKey)){
                  addTagToRowDay(row, dayKey, "NA");
                  applied++;
                }
              }
            }
          });
        });
      });

      hasUnsavedChanges = true;
      renderRosterGrid(currentWeek.data);
      runPostRenderChecks();
      syncEditorButtons();

      alert(`LBB sync complete. Tags applied: ${applied}\n\nRemember to Save draft / Publish when happy.`);
    }


function renderRosterGrid(data) {
      rosterGrid.innerHTML = "";

      if (!data || !Array.isArray(data.sections)) {
        rosterGrid.innerHTML = "<p class='muted'>No sections defined in this roster.</p>";
        return;
      }

      const effectiveReadOnly = isEffectiveReadOnly();

      data.sections.forEach((section) => {
        ensureUncovered(section);

        const sectionDiv = document.createElement("div");
        sectionDiv.classList.add("mt-3");

        const headerDiv = document.createElement("div");
        headerDiv.classList.add("flex-between", "mb-1");
        headerDiv.innerHTML = `
          <div class="flex">
            <h3 style="margin:0;font-size:0.95rem;color:#0f172a;">${section.title || "Section"}</h3>
            ${section.note ? `<span class="tag">${section.note}</span>` : ""}
          </div>
        `;
        sectionDiv.appendChild(headerDiv);

        const table = document.createElement("table");
        table.classList.add("roster-table");
        const thead = document.createElement("thead");

        // Header row 1: dates
        const dateRow = document.createElement("tr");
        const thBlank = document.createElement("th");
        dateRow.appendChild(thBlank);
        ["sun", "mon", "tue", "wed", "thu", "fri", "sat"].forEach((dayKey) => {
          const th = document.createElement("th");
          const d = currentWeek ? getDateForDay(currentWeek.week_ending, dayKey) : null;
          th.textContent = d ? String(d.getDate()).padStart(2, "0") : "";
          dateRow.appendChild(th);
        });
        const thBlankEnd = document.createElement("th");
        dateRow.appendChild(thBlankEnd);
        thead.appendChild(dateRow);

        // Header row 2: day labels
        const headerRow = document.createElement("tr");
        headerRow.innerHTML = `
          <th>Name</th>
          <th>Sun</th>
          <th>Mon</th>
          <th>Tue</th>
          <th>Wed</th>
          <th>Thu</th>
          <th>Fri</th>
          <th>Sat</th>
          <th>Remarks</th>
        `;
        thead.appendChild(headerRow);

        table.appendChild(thead);

        const tbody = document.createElement("tbody");

        // Uncovered row
        const uncoveredTr = document.createElement("tr");
        const uncoveredNameTd = document.createElement("td");
        uncoveredNameTd.textContent = "Uncovered shifts";
        uncoveredNameTd.style.fontWeight = "600";
        uncoveredNameTd.style.background = "#e5e7eb";
        uncoveredNameTd.style.textAlign = "left";
        uncoveredTr.appendChild(uncoveredNameTd);

        const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
        days.forEach((day) => {
          const td = document.createElement("td");
          const dayObj = (section.uncovered && section.uncovered[day]) || { s1: "", s2: "" };

          ["s1", "s2"].forEach((slot) => {
            const input = document.createElement("input");
            input.value = dayObj[slot] || "";
            input.dataset.sectionId = section.id;
            input.dataset.day = day;
            input.dataset.slot = slot;
            input.className = "shift-input " + classifyShift(input.value, []);
            input.style.display = "block";
            input.style.marginBottom = "2px";

            if (effectiveReadOnly) {
  input.disabled = true;
} else {
  input.addEventListener("input", handleUncoveredChange);

  // âœ… Award mode: clicking an uncovered slot selects it
  input.addEventListener("click", () => {
    if (!awardMode || !canManageRoster()) return;

    selectedUncovered = {
      weekId: currentWeek?.id,
      sectionId: section.id,
      dayKey: day,
      slot
    };

    document.querySelectorAll(".uncovered-selected")
      .forEach(el => el.classList.remove("uncovered-selected"));
    input.classList.add("uncovered-selected");
  });
}

            td.appendChild(input);
          });

          uncoveredTr.appendChild(td);
        });

        const uncoveredRemarksTd = document.createElement("td");
        uncoveredRemarksTd.textContent = "";
        uncoveredTr.appendChild(uncoveredRemarksTd);

        tbody.appendChild(uncoveredTr);

        // Staff rows
        (section.rows || []).forEach((row, rowIndex) => {
          ensureRowTags(row);

          const tr = document.createElement("tr");

          function makeCell(key) {
            const td = document.createElement("td");

            if (row.spare_origin && row.spare_origin[key]) {
              td.classList.add("spare-origin-cell");
            }

            const wrap = document.createElement("div");
            wrap.className = "shift-cell-wrap";

            const shiftValue = row.shifts?.[key] || "";

            // Build tag list for this cell
            let tags = Array.isArray(row.tags?.[key]) ? [...row.tags[key]] : [];
            // Backward compat: if RDW flag set but tag missing, inject it for display
            if (row.rdw && row.rdw[key]) {
              const hasRdwTag = tags.some((t) => String(t).toUpperCase() === "RDW");
              if (!hasRdwTag) tags.push("RDW");
            }

            const input = document.createElement("input");
            input.value = shiftValue;
            input.dataset.sectionId = section.id;
            input.dataset.rowIndex = rowIndex;
            input.dataset.field = key;
            input.className = "shift-input " + classifyShift(shiftValue, tags);
            input.setAttribute("list", "shift-presets");

            if (effectiveReadOnly) {
  input.disabled = true;
} else {
  // âœ… correct handler for staff shift cells
  input.addEventListener("input", handleShiftChange);
}

            wrap.appendChild(input);

            // Tag pills under shift
            const tagRow = document.createElement("div");
            tagRow.className = "tag-row";

            tags.forEach((tag) => {
              const tUpper = String(tag).toUpperCase();
              const pill = document.createElement("span");
              pill.classList.add("tag-pill");

              if (tUpper === "RDW") pill.classList.add("tag-pill-rdw");
              else if (tUpper === "AL") pill.classList.add("tag-pill-al");
              else if (tUpper === "CL") pill.classList.add("tag-pill-cl");
              else if (tUpper === "SICK") pill.classList.add("tag-pill-sick");
              else if (tUpper === "BO") pill.classList.add("tag-pill-bo");
              else if (tUpper === "LROP" || tUpper === "HROP") pill.classList.add("tag-pill-rop");
              else if (tUpper === "HGD") pill.classList.add("tag-pill-hgd");

              pill.textContent = tUpper;
              tagRow.appendChild(pill);
            });

            wrap.appendChild(tagRow);
            td.appendChild(wrap);

           // Cell click handler: Award mode first, then normal tag mode
if (!effectiveReadOnly) {
  td.addEventListener("click", async (e) => {
    const target = e.target;

    // Ignore pill clicks only
    if (target.classList && target.classList.contains("tag-pill")) return;

    // ===== AWARD MODE =====
    if (awardMode && selectedUncovered && canManageRoster()) {
      if (!selectedUncovered.weekId) {
        alert("Open a week before awarding.");
        return;
      }

      // Must award into the SAME day as the uncovered slot selected
      if (key !== selectedUncovered.dayKey) {
        alert(`That uncovered shift is for ${selectedUncovered.dayKey.toUpperCase()}. Click the matching day cell to award it.`);
        return;
      }

      const staffName = (row.staff_name || "").trim();
      if (!staffName) {
        alert("That row has no staff name.");
        return;
      }

      const ok = confirm(
        `Award selected uncovered shift to ${staffName} on ${key.toUpperCase()}?`
      );
      if (!ok) return;

      const success = await awardUncoveredShift({
        weekId: selectedUncovered.weekId,
        sectionId: selectedUncovered.sectionId, // source section (where uncovered lives)
        dayKey: selectedUncovered.dayKey,
        slot: selectedUncovered.slot,
        staffName
      });

      if (success) {
        setAwardMode(false);
      }
      return;
    }

    // ===== NORMAL TAG MODE =====
    if (!activeTag) return;
    applyTagToCell(section.id, rowIndex, key);
  });
}

            return td;
          }

          const nameTd = document.createElement("td");
          const nameInput = document.createElement("input");
          nameInput.value = row.staff_name || "";
          nameInput.dataset.sectionId = section.id;
          nameInput.dataset.rowIndex = rowIndex;
          nameInput.dataset.field = "staff_name";

          if (effectiveReadOnly) {
            nameInput.disabled = true;
          } else {
            nameInput.addEventListener("input", handleNameChange);
          }

          nameTd.appendChild(nameInput);
          tr.appendChild(nameTd);

          ["sun", "mon", "tue", "wed", "thu", "fri", "sat"].forEach((day) => {
            tr.appendChild(makeCell(day));
          });

          const remarksTd = document.createElement("td");
          const remarksInput = document.createElement("textarea");
          remarksInput.value = row.remarks || "";
          remarksInput.dataset.sectionId = section.id;
          remarksInput.dataset.rowIndex = rowIndex;
          remarksInput.dataset.field = "remarks";
          remarksInput.className = "remark-input";
          remarksInput.rows = 1;

          if (effectiveReadOnly) {
            remarksInput.disabled = true;
          } else {
            const autoResize = () => {
              remarksInput.style.height = "auto";
              remarksInput.style.height = remarksInput.scrollHeight + "px";
            };
            remarksInput.addEventListener("input", (e) => {
              autoResize();
              handleRemarksChange(e);
            });
            autoResize();
          }

          remarksTd.appendChild(remarksInput);
          tr.appendChild(remarksTd);

          tbody.appendChild(tr);
        });

        table.appendChild(tbody);

        // Highlight current day column if this roster week contains today's date
        if (currentWeek && weekContainsToday(currentWeek.week_ending)) {
          const today = new Date();
          const jsDay = today.getDay();
          const dayIndex = jsDay;

          const headerRows = thead.querySelectorAll("tr");
          if (headerRows.length >= 2) {
            const dayHeaderCells = headerRows[1].querySelectorAll("th");
            if (dayHeaderCells[dayIndex + 1]) {
              dayHeaderCells[dayIndex + 1].classList.add("today-col");
            }
          }

          const bodyRows = tbody.querySelectorAll("tr");
          bodyRows.forEach((rowEl) => {
            const cells = rowEl.querySelectorAll("td");
            if (cells[dayIndex + 1]) {
              cells[dayIndex + 1].classList.add("today-col");
            }
          });
        }

        sectionDiv.appendChild(table);
        rosterGrid.appendChild(sectionDiv);
      });

      applyRosterFilter();
    }

    // ===== CHANGE HANDLERS =====
    function handleUncoveredChange(e) {
      if (isEffectiveReadOnly()) return;

      const input = e.target;
      enforceShiftInputRules(input);
      const sectionId = input.dataset.sectionId;
      const day = input.dataset.day;
      const slot = input.dataset.slot || "s1";

      const sections = currentWeek.data.sections || [];
      const section = sections.find((s) => s.id === sectionId);
      if (!section) return;

      ensureUncovered(section);
      const dayObj = section.uncovered[day];
      if (!dayObj) return;

            dayObj[slot] = input.value;
      input.className = "shift-input " + classifyShift(input.value, []);

      hasUnsavedChanges = true;
      updateCoverageBanner();
    }

    function handleNameChange(e) {
      if (isEffectiveReadOnly()) return;

      const input = e.target;
      const sectionId = input.dataset.sectionId;
      const rowIndex = parseInt(input.dataset.rowIndex, 10);

      const sections = currentWeek.data.sections || [];
      const section = sections.find((s) => s.id === sectionId);
      if (!section) return;

            if (!section.rows[rowIndex]) section.rows[rowIndex] = {};
      section.rows[rowIndex].staff_name = input.value;
      hasUnsavedChanges = true;
    }

    function handleRemarksChange(e) {
      if (isEffectiveReadOnly()) return;

      const input = e.target;
      const sectionId = input.dataset.sectionId;
      const rowIndex = parseInt(input.dataset.rowIndex, 10);

      const sections = currentWeek.data.sections || [];
      const section = sections.find((s) => s.id === sectionId);
      if (!section) return;

            if (!section.rows[rowIndex]) section.rows[rowIndex] = {};
      section.rows[rowIndex].remarks = input.value;
      hasUnsavedChanges = true;
    }

    function handleShiftChange(e) {
      if (isEffectiveReadOnly()) return;

      const input = e.target;
      enforceShiftInputRules(input);
      const sectionId = input.dataset.sectionId;
      const rowIndex = parseInt(input.dataset.rowIndex, 10);
      const field = input.dataset.field;

      const sections = currentWeek.data.sections || [];
      const section = sections.find((s) => s.id === sectionId);
      if (!section) return;

      if (!section.rows[rowIndex]) section.rows[rowIndex] = { shifts: {} };
      if (!section.rows[rowIndex].shifts) section.rows[rowIndex].shifts = {};
      if (!section.rows[rowIndex].tags) section.rows[rowIndex].tags = {};

      section.rows[rowIndex].shifts[field] = input.value;

            const tags = section.rows[rowIndex].tags[field] || [];
      input.className = "shift-input " + classifyShift(input.value, tags);

      hasUnsavedChanges = true;
      updateCoverageBanner();
    }

    // ===== SAVE / PUBLISH / PRINT =====
    btnSaveWeek.addEventListener("click", async () => {
      const role = currentProfile?.role || "viewer";
      if (!currentWeek || isPublicViewer || role === "viewer") return;

      const { data, error } = await supabase
        .from("roster_weeks")
        .update({ data: currentWeek.data })
        .eq("id", currentWeek.id)
        .select("*")
        .single();

           if (error) {
        console.error(error);
        alert("Error saving week.");
        return;
      }
      currentWeek = data;
      hasUnsavedChanges = false;
      alert("Draft saved.");
    });

async function saveVersionSnapshotForWeek(weekId, snapshotData) {
  if (!weekId || !snapshotData) return;

  try {
    const { data: existing, error: loadErr } = await supabase
      .from("roster_week_revisions")
      .select("id")
      .eq("week_id", weekId);

    if (loadErr) console.warn("saveVersionSnapshot load error", loadErr);

    const nextVersion = (existing ? existing.length : 0) + 1;

    let snapshot;
    try {
      snapshot = JSON.parse(JSON.stringify(snapshotData));
    } catch (e) {
      console.warn("saveVersionSnapshot clone error", e);
      return;
    }

    const { error: insertErr } = await supabase
      .from("roster_week_revisions")
      .insert({
        week_id: weekId,
        snapshot,
        label: `V${nextVersion}`,
        created_by: currentUser?.id || null
      });

    if (insertErr) console.warn("saveVersionSnapshot insert error", insertErr);
  } catch (e) {
    console.warn("saveVersionSnapshot exception", e);
  }
}

   
    if (btnSyncLBB) {
      
    // ===== LBB â†” Roster consistency check (published weeks) =====
    async function checkLBBMissingLeaveForCurrentWeek(){
      try{
        if (!currentWeek || !currentWeek.week_ending || !currentWeek.data) {
          if (lbbMissingBadge) { lbbMissingBadge.classList.remove("is-on"); lbbMissingBadge.style.display="none"; }
          return;
        }
        if (!supabase) return;

        // Only flag when the week is published (drafts can be mid-edit)
        const status = String(currentWeek.status || "").toLowerCase();
        if (status !== "published") {
          if (lbbMissingBadge) { lbbMissingBadge.classList.remove("is-on"); lbbMissingBadge.style.display="none"; }
          return;
        }

        const end = new Date(currentWeek.week_ending);
        if (isNaN(end)) return;
        const start = new Date(end.getTime());
        start.setDate(start.getDate() - 6);

        const startISO = start.toISOString().slice(0,10);
        const endISO   = end.toISOString().slice(0,10);

        // Pull approved LBB AL/CL entries overlapping this week
        const { data: entries, error } = await supabase
          .from("calendar_entries")
          .select("id, start_date, end_date, entry_type, status, staff_directory(canonical_name)")
          .gte("end_date", startISO)
          .lte("start_date", endISO)
          .in("entry_type", ["AL","CL"])
          .in("status", ["AUTO_APPROVED","APPROVED"]);

        if (error){
          console.warn("LBB mismatch check query error", error);
          if (lbbMissingBadge) { lbbMissingBadge.classList.remove("is-on"); lbbMissingBadge.style.display="none"; }
          return;
        }

        const days = ["sun","mon","tue","wed","thu","fri","sat"];

        // Build a quick lookup of roster tags by name+dayKey
        const rosterTagMap = new Map(); // name -> dayKey -> Set(tags)
        (currentWeek.data.sections || []).forEach(sec=>{
          (sec.rows || []).forEach(row=>{
            const name = String(row.staff_name || "").trim();
            if (!name) return;
            const byDay = new Map();
            days.forEach(k=>{
              const arr = Array.isArray(row.tags?.[k]) ? row.tags[k] : [];
              byDay.set(k, new Set(arr.map(t=>String(t).toUpperCase())));
            });
            rosterTagMap.set(name, byDay);
          });
        });

        const missing = []; // {name,date,type}
        (entries || []).forEach(e=>{
          const name = String(e.staff_directory?.canonical_name || "").trim();
          if (!name) return;
          const byDay = rosterTagMap.get(name);
          if (!byDay) return; // not on this template/week (fine)

          const eStart = new Date(e.start_date);
          const eEnd = new Date(e.end_date);
          if (isNaN(eStart) || isNaN(eEnd)) return;

          for (let i=0;i<7;i++){
            const d = new Date(start.getTime());
            d.setDate(d.getDate()+i);
            if (d < eStart || d > eEnd) continue;

            const dayKey = days[i];
            const need = String(e.entry_type || "").toUpperCase();
            const tagSet = byDay.get(dayKey);
            if (!tagSet || !tagSet.has(need)){
              missing.push({ name, date: d.toISOString().slice(0,10), type: need });
            }
          }
        });

        if (!lbbMissingBadge) return;

        if (missing.length){
          lbbMissingBadge.textContent = `âš ï¸ LBB mismatch: ${missing.length}`;
          lbbMissingBadge.classList.add("is-on");
          lbbMissingBadge.style.display="inline-flex";

          lbbMissingBadge.onclick = () => {
            const lines = missing
              .slice(0, 80)
              .map(m => `${m.date} â€” ${m.name} (${m.type})`)
              .join("\n");
            const extra = missing.length > 80 ? `\n\nâ€¦and ${missing.length-80} more` : "";
            alert(
              `Published week is missing A/L or C/L tags that exist as approved entries in Little Black Book.\n\n` +
              lines + extra +
              `\n\nFix options:\n- Use â€œSync LBB leaveâ€\n- Or manually tag the relevant cells`
            );
          };
        } else {
          lbbMissingBadge.classList.remove("is-on");
          lbbMissingBadge.style.display="none";
        }
      } catch (err){
        console.warn("LBB mismatch check failed", err);
        if (lbbMissingBadge) { lbbMissingBadge.classList.remove("is-on"); lbbMissingBadge.style.display="none"; }
      }
    }

    function runPostRenderChecks(){
      updateCoverageBanner();
      // fire-and-forget: we don't want to block UI on a warning badge
      checkLBBMissingLeaveForCurrentWeek();
    }

btnSyncLBB.addEventListener("click", async () => {
        try { await syncLeaveFromLBB(); } catch (e) { console.error(e); alert("Sync failed. Check console."); }
      });
    }

btnPublishWeek.addEventListener("click", async () => {
  const role = currentProfile?.role || "viewer";
  const canPublish =
    !isPublicViewer && (role === "admin" || role === "editor");

  if (!currentWeek || !canPublish) return;

  const payload = {
    status: "published",
    published_at: new Date().toISOString(),
    data: currentWeek.data,
    last_published_data: currentWeek.data
  };

  const { data, error } = await supabase
    .from("roster_weeks")
    .update(payload)
    .eq("id", currentWeek.id)
    .select("*")
    .single();

  if (error) {
    console.error(error);
    alert("Error publishing week.");
    return;
  }

  currentWeek = data;
  setStatusPill("published");
  syncEditorButtons();

  // ðŸ”¹ Save a versioned snapshot: V1, V2, V3...
  await saveVersionSnapshotForWeek(currentWeek.id, currentWeek.data);

  hasUnsavedChanges = false;

  await loadWeeks();
  await loadAnalyticsYears();
  await refreshAnalytics();
  await refreshExpiryWatch();
  await refreshShiftMarket();

  alert("Week published.");
});


    btnPrintWeek.addEventListener("click", () => {
      if (!currentWeek) {
        alert("Open a week before printing.");
        return;
      }
      window.print();
    });

    // ===== ANALYTICS =====
    async function loadAnalyticsYears() {
            const { data, error } = await supabase
        .from("roster_weeks")
        .select("week_ending")
        .eq("link", currentLink)
        .order("week_ending", { ascending: false });

      if (error) {
        console.error("loadAnalyticsYears error", error);
        return;
      }

      const yearsSet = new Set();
      data.forEach((w) => {
        if (!w.week_ending) return;
        const d = new Date(w.week_ending);
        if (!isNaN(d)) {
          yearsSet.add(d.getFullYear());
        }
      });

      const years = Array.from(yearsSet).sort((a, b) => b - a);
      analyticsYearSelect.innerHTML = "";

      if (!years.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No data";
        analyticsYearSelect.appendChild(opt);
        return;
      }

      years.forEach((y) => {
        const opt = document.createElement("option");
        opt.value = String(y);
        opt.textContent = y;
        analyticsYearSelect.appendChild(opt);
      });

      const currentYear = new Date().getFullYear();
      if (years.includes(currentYear)) {
        analyticsYearSelect.value = String(currentYear);
      } else {
        analyticsYearSelect.value = String(years[0]);
      }
    }

    btnRefreshAnalytics.addEventListener("click", () => {
      refreshAnalytics();
      refreshExpiryWatch();
    });

    btnToggleAnalytics.addEventListener("click", () => {
      const collapsed = analyticsBody.classList.toggle("hidden");
      btnToggleAnalytics.textContent = collapsed ? "Show" : "Hide";
    });

// Change log button listener
if (btnChangeLog) {
  btnChangeLog.addEventListener("click", () => {
    showChangeLog();
  });
}

    async function loadLeaveAllowances(year) {
      leaveAllowancesByName = {};
      currentAnalyticsYear = year;

            const { data, error } = await supabase
        .from("leave_allowances")
        .select("id, staff_name, year, al_allowance, cl_base_allowance")
        .eq("year", year)
        .eq("link", currentLink);

      if (error) {
        console.error("loadLeaveAllowances error", error);
        return;
      }

      (data || []).forEach((row) => {
        const name = (row.staff_name || "").trim();
        if (!name) return;
        leaveAllowancesByName[name] = {
          id: row.id,
          al: row.al_allowance || 0
        };
      });
    }

    // Year-scoped analytics: counts per person & weekly stats
    function computeYearAnalyticsFromWeeks(weeks, year) {
      const weeklyStats = [];
      const usageMap = {};
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      weeks.forEach((w) => {
        let weekAL = 0;
        let weekCL = 0;
        let weekSick = 0;
        let weekRDWTotal = 0;
        let weekRDWSun = 0;
        let weekUncovered = 0;

        const struct = w.data;
        if (!struct || !Array.isArray(struct.sections)) return;

        struct.sections.forEach((section) => {
          ensureUncovered(section);

          days.forEach((day, di) => {
      // Year boundary guard: weeks overlap years, but the "selected year" analytics should only count
      // days that actually fall within that calendar year.
      if (typeof year === 'number') {
        const cellDate = getDateForDay(w.week_ending, di);
        if (cellDate && cellDate.getFullYear() !== year) return;
      }

            const u = section.uncovered?.[day];
            if (typeof u === "string") {
              if (u.trim()) weekUncovered += 1;
            } else if (u && typeof u === "object") {
              if ((u.s1 || "").trim()) weekUncovered += 1;
              if ((u.s2 || "").trim()) weekUncovered += 1;
            }
          });

          (section.rows || []).forEach((row) => {
            const staffName = (row.staff_name || "").trim();
            if (staffName && !usageMap[staffName]) {
              usageMap[staffName] = {
                name: staffName,
                al: 0,
                cl: 0,
                rdwTotal: 0,
                rdwSun: 0
              };
            }

            days.forEach((day) => {
// Year-boundary guard: weeks are stored by week_ending, which can straddle year boundaries.
// Only count cells whose actual calendar date falls within the selected year.
if (typeof year === "number") {
  const _d = getDateForDay(w.week_ending, day);
  if (_d && _d.getFullYear() !== year) return;
}

              const shift = row.shifts?.[day];
              const v = (shift || "").toUpperCase();
              const tags = Array.isArray(row.tags?.[day]) ? row.tags[day] : [];
              const tagSet = new Set(tags.map((t) => String(t).toUpperCase()));

              if (!v && tagSet.size === 0) return;

              const hasAL = tagSet.has("AL") || v.includes("A/L");
              const hasCL = tagSet.has("CL") || v.includes("C/L");
              const hasSick = tagSet.has("SICK") || v.includes("SICK") || v.includes("S/L");

              if (hasAL) {
                weekAL++;
                if (staffName) usageMap[staffName].al++;
              }
              if (hasCL) {
                weekCL++;
                if (staffName) usageMap[staffName].cl++;
              }
              if (hasSick) {
                weekSick++;
              }

              const isRDW = row.rdw && row.rdw[day];
              if (isRDW) {
                weekRDWTotal++;
                if (day === "sun") weekRDWSun++;
                if (staffName) {
                  usageMap[staffName].rdwTotal++;
                  if (day === "sun") usageMap[staffName].rdwSun++;
                }
              }
            });
          });
        });

        weeklyStats.push({
          weekEnding: w.week_ending,
          label: w.label || "",
          al: weekAL,
          cl: weekCL,
          sick: weekSick,
          rdwTotal: weekRDWTotal,
          rdwSun: weekRDWSun,
          uncovered: weekUncovered
        });
      });

      const usageStats = Object.values(usageMap).filter((u) => u.name);
      usageStats.sort((a, b) => a.name.localeCompare(b.name));

      return { weeklyStats, usageStats };
    }

    // Per-person leave detail for selected year
    function computeLeaveDetailForYear(weeks, year) {
      const map = {};
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      weeks.forEach((w) => {
        const struct = w.data;
        if (!struct || !Array.isArray(struct.sections)) return;

        struct.sections.forEach((section) => {
          (section.rows || []).forEach((row) => {
            const staffName = (row.staff_name || "").trim();
            if (!staffName) return;

            if (!map[staffName]) {
              map[staffName] = {
                alDates: [],
                clDates: []
              };
            }

            days.forEach((day) => {
              const shift = row.shifts?.[day];
              const v = (shift || "").toUpperCase();
              const tags = Array.isArray(row.tags?.[day]) ? row.tags[day] : [];
              const tagSet = new Set(tags.map((t) => String(t).toUpperCase()));

              if (!v && tagSet.size === 0) return;

              const d = getDateForDay(w.week_ending, day);
              if (!d || d.getFullYear() !== year) return;

              const hasAL = tagSet.has("AL") || v.includes("A/L");
              const hasCL = tagSet.has("CL") || v.includes("C/L");

              if (hasAL) {
                map[staffName].alDates.push(d);
              }
              if (hasCL) {
                map[staffName].clDates.push(d);
              }
            });
          });
        });
      });

      return map;
    }

    // Full-history LROP/C/L credit bank
    function computeCompBankFromWeeks(weeks, today) {
      const map = {};
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      weeks.forEach((w) => {
        const struct = w.data;
        if (!struct || !Array.isArray(struct.sections)) return;

        struct.sections.forEach((section) => {
          (section.rows || []).forEach((row) => {
            const staffName = (row.staff_name || "").trim();
            if (!staffName) return;

            if (!map[staffName]) {
              map[staffName] = {
                lropDates: [],
                clUsedDates: [],
                usable: 0,
                usedLast365: 0,
                validCreditDates: []
              };
            }

            days.forEach((day) => {
              const shift = row.shifts?.[day];
              const v = (shift || "").toUpperCase();
              const tags = Array.isArray(row.tags?.[day]) ? row.tags[day] : [];
              const tagSet = new Set(tags.map((t) => String(t).toUpperCase()));
              if (!v && tagSet.size === 0) return;

              const d = getDateForDay(w.week_ending, day);
              if (!d) return;

              const hasCL = tagSet.has("CL") || v.includes("C/L");
              const hasLROP = tagSet.has("LROP") || v.includes("LROP");

              if (hasLROP) {
                map[staffName].lropDates.push(d);
              }
              if (hasCL) {
                map[staffName].clUsedDates.push(d);
              }
            });
          });
        });
      });

      const cutoff = addDays(today, -365);

      Object.entries(map).forEach(([name, rec]) => {
        const credits = rec.lropDates
          .map((d) => {
            const expiry = new Date(d.getTime());
            expiry.setFullYear(expiry.getFullYear() + 1);
            return { date: d, expiry, consumed: false };
          })
          .sort((a, b) => a.date - b.date);

        // Pair each CL use to a specific earned credit (FIFO, but only if valid at time of use)
const usedDatesSorted = (rec.clUsedDates || [])
  .slice()
  .sort((a, b) => a - b);

rec.clUsePairs = []; // [{ useDate, earnDate }]

usedDatesSorted.forEach((useDate) => {
  // Find the earliest unconsumed credit that is still valid on the use date
  const match = credits.find((c) => {
  if (c.consumed) return false;
  return c.date <= useDate && c.expiry >= useDate;
});

  if (match) {
    match.consumed = true;
    rec.clUsePairs.push({ useDate, earnDate: match.date });
  } else {
    // No credit available (data inconsistency or missing history)
    rec.clUsePairs.push({ useDate, earnDate: null });
  }
});

        const usableCredits = credits.filter(
          (c) => !c.consumed && c.expiry >= today
        );
        rec.usable = usableCredits.length < 0 ? 0 : usableCredits.length;
        rec.validCreditDates = usableCredits.map((c) => c.date);

        rec.usedLast365 = rec.clUsedDates.filter(
          (d) => d >= cutoff && d <= today
        ).length;
      });

      return map;
    }

    async function refreshAnalytics() {
      const yearStr = analyticsYearSelect.value;
      if (!yearStr) {
        analyticsWeeklyTbody.innerHTML = "";
        analyticsUsageTbody.innerHTML = "";
        analyticsLeaveTbody.innerHTML = "";
        return;
      }
      const year = Number(yearStr);

      await loadLeaveAllowances(year);

      // 1) Year-scoped stats
      const start = `${year}-01-01`;
      const end = `${year}-12-31`;

            const { data: yearWeeks, error: yearErr } = await supabase
        .from("roster_weeks")
        .select("id, week_ending, label, data")
        .eq("link", currentLink)
        .gte("week_ending", start)
        .lte("week_ending", end)
        .order("week_ending", { ascending: true });

      if (yearErr) {
        console.error("refreshAnalytics (year) error", yearErr);
        return;
      }

      const { weeklyStats, usageStats } =
        computeYearAnalyticsFromWeeks(yearWeeks || [], year);

      const leaveDetailYear = computeLeaveDetailForYear(yearWeeks || [], year);

      // 2) Full-history comp bank
      const today = new Date();
            const { data: allWeeks, error: allErr } = await supabase
        .from("roster_weeks")
        .select("id, week_ending, data")
        .eq("link", currentLink)
        .order("week_ending", { ascending: true });

      if (allErr) {
        console.error("refreshAnalytics (all weeks) error", allErr);
        return;
      }

      const compBank = computeCompBankFromWeeks(allWeeks || [], today);

      renderWeeklyAnalytics(weeklyStats);
      lastUsageStats = usageStats;
      applyUsageFilter();
      renderLeaveAnalytics(usageStats, compBank, leaveDetailYear);
    }

    // ===== SHIFT MARKET (uncovered shifts with interest) =====
    let shiftMarketStaffNames = [];

    function buildUsageMap() {
      const map = {};
      (lastUsageStats || []).forEach((u) => {
        map[u.name] = {
          rdwTotal: u.rdwTotal || 0,
          rdwSun: u.rdwSun || 0
        };
      });
      return map;
    }

    function dayKeyToIndex(dayKey) {
      const order = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
      return order.indexOf(dayKey);
    }

function computeShiftMarketStatus(entry, interested, today) {
  const oneDay = 24 * 60 * 60 * 1000;
  const shiftDate = entry.dateObj;
  if (!shiftDate) {
    return { emoji: "âšª", label: "No date available" };
  }

  const daysUntil = Math.floor((shiftDate - today) / oneDay);

  // No interest yet
  if (!interested || interested.length === 0) {
    // More than 4 weeks away: RED â€“ no bids yet, plenty of time
    if (daysUntil > 28) {
      return {
        emoji: "ðŸ”´",
        label: "No interest yet."
      };
    }

    // Within 4 weeks and still nothing: BLACK â€“ RCM needs to intervene
    return {
      emoji: "âš«",
      label: "RCM required to attempt to organise cover."
    };
  }

  // At least one interest: find earliest interest as bidding start
  let firstInterest = null;
  interested.forEach((r) => {
    if (!r.created_at) return;
    const d = new Date(r.created_at);
    if (!isNaN(d)) {
      if (!firstInterest || d < firstInterest) firstInterest = d;
    }
  });

  if (!firstInterest) {
    // Failsafe: treat as bidding but no usable created_at
    return {
      emoji: "ðŸŸ¡",
      label: "Bidding window open."
    };
  }

  const biddingEnd = new Date(firstInterest.getTime() + 14 * oneDay);
  const daysLeft = Math.max(
    0,
    Math.ceil((biddingEnd - today) / oneDay)
  );

  // YELLOW: bidding window open (first interest, < 2 weeks since, and > 4 weeks away)
  if (today < biddingEnd && daysUntil > 28) {
    return {
      emoji: "ðŸŸ¡",
      label: `Bidding window open â€“ ${daysLeft} day(s) remaining.`
    };
  }

  // GREEN: either 2+ weeks have passed since first interest OR we are within 4 weeks
  // and there is at least one bid. Someone has effectively "won".
  return {
    emoji: "ðŸŸ¢",
    label: "Interest registered â€“ allocate from ranked list."
  };
}

async function awardUncoveredShift({ weekId, sectionId, dayKey, slot, staffName }) {
  if (!canManageRoster()) {
    alert("Read-only users cannot award shifts.");
    return false;
  }

  // 1) Load the target week fresh from DB (donâ€™t trust UI state)
  const { data: week, error: weekErr } = await supabase
    .from("roster_weeks")
    .select("id, status, week_ending, data")
    .eq("id", weekId)
    .single();

  if (weekErr || !week) {
    console.error("awardUncoveredShift load week error", weekErr);
    alert("Unable to load roster week for awarding.");
    return false;
  }

  const struct = week.data;
  if (!struct || !Array.isArray(struct.sections)) {
    alert("Roster data is missing or invalid.");
    return false;
  }

  const section = struct.sections.find(s => String(s.id || "") === String(sectionId || ""));
  if (!section) {
    alert("Section not found in that roster week.");
    return false;
  }

  ensureUncovered(section);

  // 2) Pull the shift text from uncovered slot
  const u = section.uncovered?.[dayKey];
  const slots =
    typeof u === "string"
      ? { s1: u, s2: "" }
      : { s1: u?.s1 || "", s2: u?.s2 || "" };

  const shiftText = (slots[slot] || "").trim();
  if (!shiftText) {
    alert("That uncovered slot is already empty.");
    return false;
  }

// 3) Find the staff row ANYWHERE in the roster (cross-section award)
let targetSection = null;
let row = null;

for (const s of (struct.sections || [])) {
  const rows = s.rows || [];
  const found = rows.find(r => (r.staff_name || "").trim() === (staffName || "").trim());
  if (found) {
    targetSection = s;
    row = found;
    break;
  }
}

if (!row || !targetSection) {
  alert(`Staff member not found anywhere in this roster: ${staffName}`);
  return false;
}

  if (!row.shifts) row.shifts = {};
  if (!row.tags) row.tags = {};
  ensureRowTags(row);

  // 4) Determine if we must apply RDW tag
  const prior = String(row.shifts?.[dayKey] || "").trim();
const priorUpper = prior.toUpperCase();
const priorTags = Array.isArray(row.tags?.[dayKey]) ? row.tags[dayKey] : [];
const priorTagSet = new Set(priorTags.map(t => String(t).toUpperCase()));

const wasEmpty = prior === "";
const wasRD = priorUpper === "RD" || priorTagSet.has("RD"); // future-proof if you ever add RD tag
const alreadyRDW = priorTagSet.has("RDW") || (row.rdw && row.rdw[dayKey]);

  // 5) Write the shift into the personâ€™s cell
  row.shifts[dayKey] = shiftText;

  // 6) Clear the uncovered slot
  if (typeof section.uncovered?.[dayKey] === "string") {
    // legacy string shape
    section.uncovered[dayKey] = (slot === "s1") ? "" : section.uncovered[dayKey];
  } else {
    section.uncovered[dayKey][slot] = "";
  }

  // 7) If they were RD or empty (off), add RDW tag + rdw flag
  if ((wasEmpty || wasRD) && !alreadyRDW) {
    const tags = row.tags[dayKey] || [];
    if (!tags.some(t => String(t).toUpperCase() === "RDW")) tags.push("RDW");
    row.tags[dayKey] = tags;

    if (!row.rdw) row.rdw = {};
    row.rdw[dayKey] = true;
  }

  // 8) Save + publish in ONE atomic update
const publishPayload = {
  data: struct,
  status: "published",
  published_at: new Date().toISOString(),
  last_published_data: struct
};

const { data: savedWeek, error: saveErr } = await supabase
  .from("roster_weeks")
  .update(publishPayload)
  .eq("id", weekId)
  .select("*")
  .single();

if (saveErr || !savedWeek) {
  console.error("awardUncoveredShift save/publish error", saveErr);
  alert("Unable to save/publish awarded shift to roster.");
  return false;
}

// 8.5) Snapshot the published version (this is what drives change log)
await saveVersionSnapshotForWeek(weekId, struct);


  // 9) Delete interest records for that shift (clean slate)
  // This removes ALL bids for that shift once itâ€™s no longer uncovered.
  try {
    await supabase
      .from("shift_market_interest")
      .delete()
      .eq("week_id", weekId)
      .eq("section_id", sectionId || null)
      .eq("day_key", dayKey)
      .eq("slot", slot)
      .eq("link", currentLink);
  } catch (e) {
    console.warn("awardUncoveredShift cleanup interest exception", e);
  }

  // 10) If the awarded week is currently open in editor, refresh it in UI
  if (currentWeek && String(currentWeek.id) === String(weekId)) {
    // reload the updated week and re-render
    const { data: refreshed, error: refErr } = await supabase
      .from("roster_weeks")
      .select("*")
      .eq("id", weekId)
      .single();

    if (!refErr && refreshed) {
      currentWeek = refreshed;
      ensureSpareOrigin(currentWeek.data);
      renderRosterGrid(currentWeek.data);
      runPostRenderChecks();
      syncEditorButtons();
      hasUnsavedChanges = false;
    }
  }

  // 11) Refresh shift market + weeks list so the UI reflects reality
  await loadWeeks();
  await refreshShiftMarket();

  return true;
}

    async function refreshShiftMarket() {
      if (!shiftMarketTbody) return;

      shiftMarketTbody.innerHTML = "";
      shiftMarketStaffNames = [];

      // Only show for roster_weeks that are published and from "today" onwards.
      const today = new Date();
      const todayStr = today.toISOString().slice(0, 10);

      let weeksData = [];
      try {
                const { data, error } = await supabase
          .from("roster_weeks")
          .select("id, week_ending, label, status, data")
          .eq("status", "published")
          .eq("link", currentLink)
          .gte("week_ending", todayStr)
          .order("week_ending", { ascending: true });

        if (error) {
          console.warn("refreshShiftMarket roster_weeks error", error);
          return;
        }
        weeksData = data || [];
      } catch (e) {
        console.warn("refreshShiftMarket roster_weeks exception", e);
        return;
      }

      const entries = [];
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      weeksData.forEach((w) => {
        if (!w.data || !Array.isArray(w.data.sections)) return;
        w.data.sections.forEach((section) => {
          ensureUncovered(section);
          // collect names for dropdown
          (section.rows || []).forEach((row) => {
            const name = (row.staff_name || "").trim();
            if (name && !shiftMarketStaffNames.includes(name)) {
              shiftMarketStaffNames.push(name);
            }
          });

          days.forEach((dayKey) => {
            const u = section.uncovered?.[dayKey];
            if (!u) return;

            const slots = typeof u === "string"
              ? { s1: u, s2: "" }
              : { s1: u.s1 || "", s2: u.s2 || "" };

            ["s1", "s2"].forEach((slot) => {
              const val = (slots[slot] || "").trim();
              if (!val) return;

              const dateObj = getDateForDay(w.week_ending, dayKey);
              entries.push({
                weekId: w.id,
                weekEnding: w.week_ending,
                sectionId: section.id || null,
                sectionTitle: section.title || "Section",
                dayKey,
                slot,
                shiftText: val,
                dateObj
              });
            });
          });
        });
      });

      shiftMarketStaffNames.sort((a, b) => a.localeCompare(b));

      // Load existing interest registrations (if table exists)
      let interestRows = [];
      try {
                const { data: interestData, error: interestErr } = await supabase
          .from("shift_market_interest")
          .select("id, week_id, section_id, day_key, slot, staff_name, created_at, link")
          .eq("link", currentLink);

        if (interestErr) {
          console.warn("refreshShiftMarket interest error", interestErr);
        } else {
          interestRows = interestData || [];
        }
      } catch (e) {
        console.warn("refreshShiftMarket interest exception", e);
      }

      
      // Load "Peter's Notebook" notes (optional table)
      let noteRows = [];
      try {
        const { data: notesData, error: notesErr } = await supabase
          .from("shift_market_notes")
          .select("id, week_id, section_id, day_key, slot, note, created_at, created_by, link")
          .eq("link", currentLink)
          .order("created_at", { ascending: true });

        if (notesErr) {
          console.warn("refreshShiftMarket notes error", notesErr);
        } else {
          noteRows = notesData || [];
        }
      } catch (e) {
        console.warn("refreshShiftMarket notes exception", e);
      }

const interestByKey = {};
      interestRows.forEach((row) => {
        const key = `${row.week_id}|${row.section_id || ""}|${row.day_key}|${row.slot}`;
        if (!interestByKey[key]) interestByKey[key] = [];
        interestByKey[key].push(row);
      });

      
      const notesByKey = {};
      noteRows.forEach((row) => {
        const key = `${row.week_id}|${row.section_id || ""}|${row.day_key}|${row.slot}`;
        if (!notesByKey[key]) notesByKey[key] = [];
        notesByKey[key].push(row);
      });

const usageMap = buildUsageMap();

      if (!entries.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="7" class="muted">No uncovered published shifts from the current week onwards.</td>`;
        shiftMarketTbody.appendChild(tr);
        return;
      }

      entries.forEach((e) => {
  const key = `${e.weekId}|${e.sectionId || ""}|${e.dayKey}|${e.slot}`;
  const interested = (interestByKey[key] || []).slice();

  const isSunday = e.dayKey === "sun";
  interested.sort((a, b) => {
    const ua = usageMap[a.staff_name] || { rdwTotal: 0, rdwSun: 0 };
    const ub = usageMap[b.staff_name] || { rdwTotal: 0, rdwSun: 0 };
    const aScore = isSunday ? ua.rdwSun : ua.rdwTotal;
    const bScore = isSunday ? ub.rdwSun : ub.rdwTotal;
    if (aScore !== bScore) return aScore - bScore;
    return a.staff_name.localeCompare(b.staff_name);
  });

  const tr = document.createElement("tr");

  // NEW: status cell with emoji
  const statusTd = document.createElement("td");
  const status = computeShiftMarketStatus(e, interested, today);
  statusTd.textContent = status.emoji;
  statusTd.title = status.label;
  statusTd.style.textAlign = "center";
  tr.appendChild(statusTd);

  const weekTd = document.createElement("td");
  weekTd.textContent = formatUK(e.weekEnding);
  tr.appendChild(weekTd);

  const dateTd = document.createElement("td");
  dateTd.textContent = e.dateObj ? formatUK(e.dateObj.toISOString()) : "";
  tr.appendChild(dateTd);

  const sectionTd = document.createElement("td");
  sectionTd.textContent = e.sectionTitle;
  tr.appendChild(sectionTd);

  const shiftTd = document.createElement("td");
  shiftTd.textContent = e.shiftText;
  tr.appendChild(shiftTd);

  const interestTd = document.createElement("td");
  interestTd.style.textAlign = "left";

        // Everyone (including public viewer) can register interest
        const controlWrap = document.createElement("div");
        controlWrap.className = "flex";
        controlWrap.style.alignItems = "center";

        const select = document.createElement("select");
        select.className = "shift-market-name-select";
        select.dataset.shiftKey = key;

        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "Select nameâ€¦";
        select.appendChild(defaultOpt);

        shiftMarketStaffNames.forEach((name) => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
        });

        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn btn-sm";
        btn.textContent = "Register";
        btn.dataset.shiftKey = key;

        btn.addEventListener("click", async () => {
          const chosenName = select.value;
          if (!chosenName) {
            alert("Pick a name to register interest.");
            return;
          }

          try {
                        const payload = {
              week_id: e.weekId,
              section_id: e.sectionId,
              day_key: e.dayKey,
              slot: e.slot,
              staff_name: chosenName,
              link: currentLink
            };
            const { error } = await supabase
              .from("shift_market_interest")
              .upsert(payload, {
                onConflict: "week_id,section_id,day_key,slot,staff_name,link"
              });
            if (error) {
              console.warn("Register interest error", error);
              alert("Unable to register interest (backend).");
              return;
            }
            await refreshShiftMarket();
          } catch (err) {
            console.warn("Register interest exception", err);
            alert("Unable to register interest.");
          }
        });

        controlWrap.appendChild(select);
        controlWrap.appendChild(btn);
        interestTd.appendChild(controlWrap);

       const rankDiv = document.createElement("div");
rankDiv.className = "muted";
rankDiv.style.fontSize = "0.75rem";
rankDiv.style.marginTop = "0.25rem";

if (interested.length) {
  rankDiv.textContent = "Ranked interest: ";

  interested.forEach((r) => {
    const u = usageMap[r.staff_name] || { rdwTotal: 0, rdwSun: 0 };
    const score = isSunday ? u.rdwSun : u.rdwTotal;
    const label = isSunday ? `Sun RDW: ${score}` : `RDW: ${score}`;

    const pill = document.createElement("span");
    pill.textContent = `${r.staff_name} (${label})`;
    pill.style.cursor = "pointer";
    pill.style.textDecoration = "underline";
    pill.style.textDecorationStyle = "dotted";
    pill.style.marginRight = "0.35rem";

    pill.addEventListener("click", async () => {
      // If read-only, keep the old behaviour (remove only)
      if (!canManageRoster()) {
        const sure = confirm(`Remove interest for ${r.staff_name} on this shift?`);
        if (!sure) return;

        const { error } = await supabase
          .from("shift_market_interest")
          .delete()
          .eq("id", r.id);

        if (error) {
          console.warn("Remove interest error", error);
          alert("Unable to remove interest.");
          return;
        }
        await refreshShiftMarket();
        return;
      }

      // Admin/editor: offer Award or Remove
      const choice = prompt(
        `Action for ${r.staff_name}?\nType:\n  A = Award shift\n  R = Remove interest\n\n(Anything else cancels)`
      );

      if (!choice) return;

      const c = choice.trim().toUpperCase();

      if (c === "R") {
        const sure = confirm(`Remove interest for ${r.staff_name} on this shift?`);
        if (!sure) return;

        const { error } = await supabase
          .from("shift_market_interest")
          .delete()
          .eq("id", r.id);

        if (error) {
          console.warn("Remove interest error", error);
          alert("Unable to remove interest.");
          return;
        }

        await refreshShiftMarket();
        return;
      }

      if (c === "A") {
        const ok = confirm(
          `Award this uncovered shift to ${r.staff_name}?\n\nThis will:\n- Remove it from Uncovered\n- Put it into their cell\n- Add RDW if they were RD/empty`
        );
        if (!ok) return;

        const success = await awardUncoveredShift({
          weekId: e.weekId,
          sectionId: e.sectionId,
          dayKey: e.dayKey,
          slot: e.slot,
          staffName: r.staff_name
        });

        if (success) {
          alert(`Awarded to ${r.staff_name}.`);
        }
        return;
      }

      // else cancel
    });

    // âœ… this was missing in your version
    rankDiv.appendChild(pill);
  });

} else {
  rankDiv.textContent = "No interest registered yet.";
}

interestTd.appendChild(rankDiv);

        tr.appendChild(interestTd);

        // --- Peter's Notebook (notes) ---
        const notesTd = document.createElement("td");
        notesTd.style.textAlign = "left";

        const notes = notesByKey[key] || [];
        const notesWrap = document.createElement("div");
        notesWrap.className = "flex";
        notesWrap.style.alignItems = "center";
        notesWrap.style.gap = "0.35rem";

        const btnAddNote = document.createElement("button");
        btnAddNote.className = "btn btn-sm";
        btnAddNote.textContent = "Add Note";
        btnAddNote.disabled = !canManageRoster();
        btnAddNote.title = canManageRoster()
          ? "Add a note about who this shift was offered to."
          : "Sign in as editor/admin to add notes.";

        btnAddNote.addEventListener("click", async () => {
          const txt = prompt("Add note for this shift (e.g., offered to X, called Y, waiting reply):");
          if (!txt || !txt.trim()) return;

          const payload = {
            week_id: e.weekId,
            section_id: e.sectionId,
            day_key: e.dayKey,
            slot: e.slot,
            link: currentLink,
            note: txt.trim(),
            created_by: (currentProfile?.full_name || currentUser?.email || "unknown")
          };

          try {
            const { error } = await supabase.from("shift_market_notes").insert(payload);
            if (error) {
              console.warn("Add note failed", error);
              alert("Couldn't save note. Check RLS/policies for shift_market_notes.");
              return;
            }
            await refreshShiftMarket();
          } catch (err) {
            console.warn("Add note exception", err);
            alert("Couldn't save note (exception).");
          }
        });

        const btnShowNotes = document.createElement("button");
        btnShowNotes.className = "btn btn-sm";
        btnShowNotes.textContent = notes.length ? `Show notes (${notes.length})` : "No notes";
        btnShowNotes.disabled = !notes.length;

        btnShowNotes.addEventListener("click", () => {
          // Toggle a detail row directly under this row
          const next = tr.nextElementSibling;
          if (next && next.classList && next.classList.contains("shift-note-row") && next.dataset.shiftKey === key) {
            next.remove();
            btnShowNotes.textContent = `Show notes (${notes.length})`;
            return;
          }

          // remove any existing notes row for this key elsewhere (optional tidy)
          const existing = shiftMarketTbody.querySelector(`tr.shift-note-row[data-shift-key="${key}"]`);
          if (existing) existing.remove();

          const detailTr = document.createElement("tr");
          detailTr.className = "shift-note-row";
          detailTr.dataset.shiftKey = key;

          const detailTd = document.createElement("td");
          detailTd.colSpan = 7; // status, week ending, date, section, shift, interest, notebook

          const box = document.createElement("div");
          box.style.padding = "0.5rem 0.75rem";
          box.style.background = "rgba(17,24,39,0.03)";
          box.style.border = "1px solid rgba(17,24,39,0.12)";
          box.style.borderRadius = "0.75rem";

          const title = document.createElement("div");
          title.style.fontWeight = "700";
          title.style.marginBottom = "0.35rem";
          title.textContent = "Peterâ€™s Notebook";
          box.appendChild(title);

          const ul = document.createElement("ul");
          ul.style.margin = "0";
          ul.style.paddingLeft = "1.1rem";

          notes.forEach((n) => {
            const li = document.createElement("li");
            const when = n.created_at ? formatUK(n.created_at) : "";
            const who = n.created_by ? ` Â· ${n.created_by}` : "";
            li.textContent = `${n.note}${when ? " â€” " + when : ""}${who}`;
            ul.appendChild(li);
          });

          box.appendChild(ul);
          detailTd.appendChild(box);
          detailTr.appendChild(detailTd);

          tr.insertAdjacentElement("afterend", detailTr);
          btnShowNotes.textContent = "Hide notes";
        });

        notesWrap.appendChild(btnShowNotes);
        notesWrap.appendChild(btnAddNote);
        notesTd.appendChild(notesWrap);
        tr.appendChild(notesTd);

        shiftMarketTbody.appendChild(tr);
      });
    }

function clamp(n, min, max) {
  return Math.max(min, Math.min(max, n));
}

function heatBand0to35(value) {
  const v = Number(value || 0);

  if (v <= 0) return 0;     // 0
  if (v <= 5) return 1;     // 1â€“5
  if (v <= 10) return 2;    // 6â€“10
  if (v <= 15) return 3;    // 11â€“15
  if (v <= 20) return 4;    // 16â€“20
  if (v <= 25) return 5;    // 21â€“25
  return 6;                // 26â€“35+
}

function heatClass(value) {
  const band = heatBand0to35(value);
  return `hm hm-${band}`;
}

// Optional: tooltip text
function heatTitle(label, value) {
  return `${label}: ${value}`;
}

    function renderWeeklyAnalytics(rows) {
  analyticsWeeklyTbody.innerHTML = "";
  if (!rows.length) return;

  rows.forEach((r) => {
    const tr = document.createElement("tr");

    tr.innerHTML = `
      <td>${formatUK(r.weekEnding)}</td>

      <td class="${heatClass(r.al)}" title="${heatTitle("A/L days", r.al)}">${r.al}</td>
      <td class="${heatClass(r.cl)}" title="${heatTitle("C/L days", r.cl)}">${r.cl}</td>
      <td class="${heatClass(r.sick)}" title="${heatTitle("Sick days", r.sick)}">${r.sick}</td>

      <td class="${heatClass(r.rdwTotal)}" title="${heatTitle("RDW (all)", r.rdwTotal)}">${r.rdwTotal}</td>
      <td class="${heatClass(r.rdwSun)}" title="${heatTitle("RDW (Sun)", r.rdwSun)}">${r.rdwSun}</td>

      <td class="${heatClass(r.uncovered)}" title="${heatTitle("Uncovered shifts", r.uncovered)}">${r.uncovered}</td>
    `;

    analyticsWeeklyTbody.appendChild(tr);
  });
}

    function renderUsageAnalytics(rows) {
      analyticsUsageTbody.innerHTML = "";
      if (!rows.length) return;

      rows.forEach((r) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td style="text-align:left;">${r.name}</td>
          <td>${r.al}</td>
          <td>${r.cl}</td>
          <td>${r.rdwTotal}</td>
          <td>${r.rdwSun}</td>
        `;
        analyticsUsageTbody.appendChild(tr);
      });
    }

    function leaveRagClass(pct) {
      if (pct === null || pct === undefined) return "";
      if (pct > 90) return "leave-red";
      if (pct >= 70) return "leave-amber";
      return "leave-green";
    }

    // A/L (year) + C/L used (rolling 12m) + C/L usable (bank) + expandable details
    function renderLeaveAnalytics(usageRows, compBank, detailYearMap) {
      analyticsLeaveTbody.innerHTML = "";

      const usageByName = {};
      (usageRows || []).forEach((u) => {
        usageByName[u.name] = u;
      });

            const names = new Set([
        ...Object.keys(usageByName),
        ...Object.keys(compBank || {})
      ]);

      if (!names.size) return;

      const role = currentProfile?.role || "viewer";
      const canEditAllowances = !isPublicViewer && role === "admin";

      Array.from(names).sort().forEach((name) => {
        const usage = usageByName[name] || { al: 0, cl: 0 };
        const allowanceRow = leaveAllowancesByName[name] || { al: 0 };
        const comp = (compBank && compBank[name]) || {
          usable: 0,
          usedLast365: 0,
          validCreditDates: []
        };
        const detail = (detailYearMap && detailYearMap[name]) || {
          alDates: [],
          clDates: []
        };

        const alUsed = usage.al || 0;
        const alAllowance = allowanceRow.al || 0;
        const alPct = alAllowance > 0 ? Math.round((alUsed / alAllowance) * 100) : null;
        const alClass = leaveRagClass(alPct);

        const clUsedRolling = comp.usedLast365 || 0;
        const clUsableBalance = comp.usable || 0;

        const mainTr = document.createElement("tr");
        mainTr.className = "leave-main-row";
        mainTr.innerHTML = `
          <td style="text-align:left;">
            <button class="leave-toggle" type="button" aria-label="Toggle details">+</button>
            <span>${name}</span>
          </td>
          <td>${alUsed}</td>
          <td></td>
          <td></td>
          <td>${clUsedRolling}</td>
          <td></td>
        `;

        const tds = mainTr.querySelectorAll("td");

        const alInput = document.createElement("input");
        alInput.type = "number";
        alInput.min = "0";
        alInput.value = alAllowance;
        alInput.style.width = "4rem";
        alInput.dataset.type = "al-allowance";
        alInput.dataset.name = name;
        if (!canEditAllowances) alInput.disabled = true;
        tds[2].appendChild(alInput);

        if (alPct === null) {
          tds[3].innerHTML = `<span class="muted" style="font-size:0.7rem;">n/a</span>`;
        } else {
          const span = document.createElement("span");
          span.className = `leave-pill ${alClass}`;
          span.textContent = `${alPct}%`;
          tds[3].appendChild(span);
        }

        tds[5].textContent = clUsableBalance;

        const detailTr = document.createElement("tr");
        detailTr.className = "leave-detail-row hidden";
        const detailTd = document.createElement("td");
        detailTd.colSpan = 6;

        const block = document.createElement("div");
        block.className = "leave-detail-block";

        // A/L list
        const alHeader = document.createElement("h4");
        alHeader.textContent = "A/L used (selected year)";
        block.appendChild(alHeader);
        const alUl = document.createElement("ul");
        if (detail.alDates.length) {
          detail.alDates
            .sort((a, b) => a - b)
            .forEach((d) => {
              const li = document.createElement("li");
              li.textContent = formatUK(d.toISOString());
              alUl.appendChild(li);
            });
        } else {
          const li = document.createElement("li");
          li.textContent = "None recorded.";
          alUl.appendChild(li);
        }
        block.appendChild(alUl);

        // C/L used (year)
        const clHeader = document.createElement("h4");
        clHeader.textContent = "C/L used (selected year)";
        block.appendChild(clHeader);
        const clUl = document.createElement("ul");
        if (detail.clDates.length) {
  // Build a lookup of CL-use-date -> earned-date(s)
  const pairRows = (comp && comp.clUsePairs) ? comp.clUsePairs : [];
  const earnQueueByUse = {};

  pairRows.forEach((p) => {
    const useKey = p.useDate ? p.useDate.toISOString().slice(0, 10) : "";
    if (!useKey) return;
    if (!earnQueueByUse[useKey]) earnQueueByUse[useKey] = [];
    earnQueueByUse[useKey].push(p.earnDate);
  });

  // Render each CL date in the selected year, with earn date in brackets
  detail.clDates
    .sort((a, b) => a - b)
    .forEach((d) => {
      const useKey = d.toISOString().slice(0, 10);
      const q = earnQueueByUse[useKey] || [];
      const earnDate = q.length ? q.shift() : null;

      const li = document.createElement("li");
      if (earnDate) {
  const today = new Date();

  const label =
    earnDate > today
      ? `${formatUK(earnDate.toISOString())} (future)`
      : formatUK(earnDate.toISOString());

  li.textContent = `${formatUK(d.toISOString())} (earned ${label})`;
} else {
  li.textContent = `${formatUK(d.toISOString())} (earned date unknown)`;
}
      clUl.appendChild(li);
    });
} else {
  const li = document.createElement("li");
  li.textContent = "None recorded.";
  clUl.appendChild(li);
}
        block.appendChild(clUl);

        // Valid credits
        const tokHeader = document.createElement("h4");
        tokHeader.textContent = "Current valid C/L credits (earn dates)";
        block.appendChild(tokHeader);
        const tokUl = document.createElement("ul");
        if (comp.validCreditDates && comp.validCreditDates.length) {
          comp.validCreditDates
            .sort((a, b) => a - b)
            .forEach((d) => {
              const li = document.createElement("li");
              li.textContent = formatUK(d.toISOString());
              tokUl.appendChild(li);
            });
        } else {
          const li = document.createElement("li");
          li.textContent = "No valid credits remaining.";
          tokUl.appendChild(li);
        }
        block.appendChild(tokUl);

        detailTd.appendChild(block);
        detailTr.appendChild(detailTd);

        analyticsLeaveTbody.appendChild(mainTr);
        analyticsLeaveTbody.appendChild(detailTr);
      });

      // Wire up expand/collapse
      analyticsLeaveTbody.querySelectorAll(".leave-toggle").forEach((btn) => {
        btn.addEventListener("click", () => {
          const row = btn.closest("tr");
          const detailRow = row.nextElementSibling;
          if (!detailRow || !detailRow.classList.contains("leave-detail-row")) return;
          const isHidden = detailRow.classList.toggle("hidden");
          btn.textContent = isHidden ? "+" : "âˆ’";
        });
      });
    }

    // Save A/L allowances
    btnSaveAllowances.addEventListener("click", async () => {
  const role = currentProfile?.role || "viewer";
  const isAdmin = !isPublicViewer && role === "admin";
  if (!isAdmin) {
    alert("You do not have permission to edit allowances.");
    return;
  }

  if (!currentAnalyticsYear) {
    alert("No analytics year selected.");
    return;
  }

      const rows = analyticsLeaveTbody.querySelectorAll("tr.leave-main-row");
      const payloads = [];

      rows.forEach((tr) => {
        const nameCell = tr.querySelector("td span");
        if (!nameCell) return;
        const name = nameCell.textContent.trim();
        if (!name) return;

        const alInput = tr.querySelector('input[data-type="al-allowance"]');
        const alAllowance = alInput ? Number(alInput.value || "0") : 0;

                payloads.push({
          staff_name: name,
          year: Number(currentAnalyticsYear),
          al_allowance: alAllowance,
          cl_base_allowance: 0,
          link: currentLink
        });
      });

      if (!payloads.length) return;

      leaveSaveStatus.textContent = "Savingâ€¦";

      const { error } = await supabase
        .from("leave_allowances")
               .upsert(payloads, { onConflict: "staff_name,year,link" });

      if (error) {
        console.error("save allowances error", error);
        leaveSaveStatus.textContent = "Error saving allowances.";
        return;
      }

      leaveSaveStatus.textContent = "Allowances saved.";
      await refreshAnalytics();
    });

    function applyUsageFilter() {
      const term = (usageFilterInput.value || "").trim().toLowerCase();
      if (!term) {
        renderUsageAnalytics(lastUsageStats);
      } else {
        const filtered = lastUsageStats.filter((u) =>
          u.name.toLowerCase().includes(term)
        );
        renderUsageAnalytics(filtered);
      }
    }

    usageFilterInput.addEventListener("input", applyUsageFilter);

    // ===== PER-WEEK ROSTER FILTER =====
    function applyRosterFilter() {
      if (!rosterFilterInput) return;
      const term = (rosterFilterInput.value || "").trim().toLowerCase();

      const tables = rosterGrid.querySelectorAll("table");
      tables.forEach((table) => {
        const rows = table.querySelectorAll("tbody tr");

        rows.forEach((tr, index) => {
          if (index === 0) {
            tr.style.display = "";
            return;
          }

          const nameInput = tr.querySelector("td:first-child input");
          if (!nameInput) return;

          const name = (nameInput.value || "").toLowerCase();

          if (!term || name.includes(term)) {
            tr.style.display = "";
          } else {
            tr.style.display = "none";
          }
        });
      });
    }

    if (rosterFilterInput) {
      rosterFilterInput.addEventListener("input", applyRosterFilter);
    }


    function normaliseCellTags(row, dayKey) {
      const tagsArr = Array.isArray(row.tags?.[dayKey]) ? row.tags[dayKey] : [];
      const set = new Set(tagsArr.map((t) => String(t).toUpperCase()));
      if (row.rdw && row.rdw[dayKey]) {
        set.add("RDW");
      }
      return Array.from(set).sort();
    }

    function describeShiftAndTags(shift, tags) {
      const v = (shift || "").trim();
      const t = (tags || []).filter((x) => x).join(", ");
      if (v && t) return `${v} + ${t}`;
      if (v) return v;
      if (t) return t;
      return "Empty";
    }

   function buildChangeLog(oldData, newData, weekRow, options = {}) {
  const includeUncovered = options.includeUncovered !== false; // default = true

  if (!oldData || !newData) return "";
  if (!Array.isArray(oldData.sections) || !Array.isArray(newData.sections)) return "";

  const lines = [];
  const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

  const oldSections = oldData.sections || [];
  const newSections = newData.sections || [];

  const sectionCount = Math.max(oldSections.length, newSections.length);

  for (let si = 0; si < sectionCount; si++) {
    const oldSection = oldSections[si] || { rows: [] };
    const newSection = newSections[si] || { rows: [] };

    const oldRows = oldSection.rows || [];
    const newRows = newSection.rows || [];
    const rowCount = Math.max(oldRows.length, newRows.length);

    for (let ri = 0; ri < rowCount; ri++) {
      const oRow = oldRows[ri] || { shifts: {}, tags: {} };
      const nRow = newRows[ri] || { shifts: {}, tags: {} };

      const name = (nRow.staff_name || oRow.staff_name || "").trim();
      if (!name) continue;

      days.forEach((dayKey) => {
        const oldShift = oRow.shifts?.[dayKey] || "";
        const newShift = nRow.shifts?.[dayKey] || "";

        const oldTags = normaliseCellTags(oRow, dayKey);
        const newTags = normaliseCellTags(nRow, dayKey);

        const sameShift = String(oldShift || "").trim() === String(newShift || "").trim();
        const sameTags =
          oldTags.length === newTags.length &&
          oldTags.every((t, idx) => t === newTags[idx]);

        if (sameShift && sameTags) return;

        const d = getDateForDay(weekRow.week_ending, dayKey);
        const dateStr = d ? formatUK(d.toISOString()) : dayKey.toUpperCase();

        const fromDesc = describeShiftAndTags(oldShift, oldTags);
        const toDesc = describeShiftAndTags(newShift, newTags);

        lines.push(`- ${name} ${dateStr}: ${fromDesc} -> ${toDesc}`);
      });
    }
  }

  if (!includeUncovered) {
    return lines.join("\n");
  }

  // Append current uncovered shifts (newData)
  const sections = newData.sections || [];
  const uncoveredLines = [];
  sections.forEach((section) => {
    ensureUncovered(section);
    days.forEach((dayKey) => {
      const u = section.uncovered?.[dayKey];
      if (!u) return;

      const slots =
        typeof u === "string"
          ? { s1: u, s2: "" }
          : { s1: u.s1 || "", s2: u.s2 || "" };

      ["s1", "s2"].forEach((slot) => {
        const val = (slots[slot] || "").trim();
        if (!val) return;
        const d = getDateForDay(weekRow.week_ending, dayKey);
        const dateStr = d ? formatUK(d.toISOString()) : dayKey.toUpperCase();
        const title = section.title || "Section";
        uncoveredLines.push(`- Uncovered: ${title} ${dateStr} (${slot.toUpperCase()}) ${val}`);
      });
    });
  });

  if (uncoveredLines.length) {
    if (lines.length) {
      lines.push("");
      lines.push("Uncovered shifts:");
    } else {
      lines.push("Uncovered shifts:");
    }
    uncoveredLines.forEach((l) => lines.push(l));
  }

  return lines.join("\n");
}

async function showChangeLog() {
  if (!currentWeek || !currentWeek.id) {
    alert("Open a week before viewing the change log.");
    return;
  }

  let revisions = [];
  try {
    const { data, error } = await supabase
      .from("roster_week_revisions")
      .select("id, week_id, snapshot, label, created_at")
      .eq("week_id", currentWeek.id)
      .order("created_at", { ascending: true });

    if (error) {
      console.error("showChangeLog load error", error);
      alert("Unable to load change log.");
      return;
    }
    revisions = data || [];
  } catch (e) {
    console.error("showChangeLog exception", e);
    alert("Unable to load change log.");
    return;
  }

  if (!revisions.length) {
    alert("No published versions recorded yet for this week.");
    return;
  }

  const lines = [];

  revisions.forEach((rev, idx) => {
    const versionNumber = idx + 1;
    const label = rev.label || `V${versionNumber}`;
    const when = rev.created_at ? formatUK(rev.created_at) : "Unknown date";

    lines.push(`Version ${label} (published ${when})`);
    lines.push("".padEnd(40, "-"));

    if (idx === 0) {
      // No previous snapshot to diff against
      lines.push("Initial publication from draft.");
    } else {
      const prevSnap = revisions[idx - 1].snapshot;
      const diffText = buildChangeLog(prevSnap, rev.snapshot, currentWeek, {
        includeUncovered: false
      });
      lines.push(diffText || "No changes detected.");
    }

    lines.push("");
  });

  // Current uncovered summary from the latest version
  const latest = revisions[revisions.length - 1];
  const uncoveredText = buildChangeLog(
    latest.snapshot,
    latest.snapshot,
    currentWeek,
    { includeUncovered: true }
  );

  if (uncoveredText && uncoveredText.trim()) {
    lines.push("");
    lines.push("Current uncovered shifts (latest version):");
    lines.push(uncoveredText);
  }

  const finalText = lines.join("\n");

  let win;
  try {
    win = window.open("", "_blank", "width=900,height=700");
  } catch (e) {
    console.warn("Unable to open window for change log", e);
  }

  if (win) {
    const safe = finalText
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
    win.document.write("<!doctype html><title>Roster change log</title>");
    win.document.write(
      "<pre style='font-family:system-ui,monospace;font-size:12px;white-space:pre-wrap;'>" +
        safe +
      "</pre>"
    );
    win.document.close();
  } else {
    console.log("Roster change log:\n" + finalText);
    alert("Change log written to console (could not open a new window).");
  }
}

    // ===== COVERAGE BANNER =====
    function computeWeekMetrics(weekRow) {
      const stats = { al: 0, cl: 0, sick: 0, rdwTotal: 0, rdwSun: 0, uncovered: 0 };
      if (!weekRow || !weekRow.data || !Array.isArray(weekRow.data.sections)) return stats;

      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
      weekRow.data.sections.forEach((section) => {
        ensureUncovered(section);

        days.forEach((day) => {
          const u = section.uncovered?.[day];

          if (typeof u === "string") {
            if (u.trim()) stats.uncovered += 1;
          } else if (u && typeof u === "object") {
            if ((u.s1 || "").trim()) stats.uncovered += 1;
            if ((u.s2 || "").trim()) stats.uncovered += 1;
          }
        });

        (section.rows || []).forEach((row) => {
          days.forEach((day) => {
            const shift = row.shifts?.[day];
            const v = (shift || "").toUpperCase();
            const tags = Array.isArray(row.tags?.[day]) ? row.tags[day] : [];
            const tagSet = new Set(tags.map((t) => String(t).toUpperCase()));

            if (!v && tagSet.size === 0) return;

            const hasAL = tagSet.has("AL") || v.includes("A/L");
            const hasCL = tagSet.has("CL") || v.includes("C/L");
            const hasSick = tagSet.has("SICK") || v.includes("SICK") || v.includes("S/L");

            if (hasAL) stats.al++;
            if (hasCL) stats.cl++;
            if (hasSick) stats.sick++;

            const isRDW = row.rdw && row.rdw[day];
            if (isRDW) {
              stats.rdwTotal++;
              if (day === "sun") stats.rdwSun++;
            }
          });
        });
      });

      return stats;
    }

    function updateCoverageBanner() {
      if (!currentWeek) {
        coveragePill.textContent = "Coverage: n/a";
        coveragePill.classList.remove("cov-good", "cov-amber", "cov-red");
        coverageSummary.textContent = "No metrics available yet.";
        return;
      }

      const stats = computeWeekMetrics(currentWeek);

      coveragePill.classList.remove("cov-good", "cov-amber", "cov-red");
      let label = "n/a";
      let cls = "";

      if (stats.uncovered === 0) {
        label = "Green";
        cls = "cov-good";
      } else if (stats.uncovered <= 4) {
        label = "Amber";
        cls = "cov-amber";
      } else {
        label = "Red";
        cls = "cov-red";
      }

      coveragePill.textContent = `Coverage: ${label}`;
      if (cls) coveragePill.classList.add(cls);

      coverageSummary.textContent =
        `Uncovered: ${stats.uncovered} â€¢ ` +
        `A/L: ${stats.al} â€¢ C/L: ${stats.cl} â€¢ Sick: ${stats.sick} â€¢ ` +
        `RDW: ${stats.rdwTotal} (Sun ${stats.rdwSun})`;
    }

    // ===== COMP LEAVE EXPIRY WATCH =====
    async function refreshExpiryWatch() {
  analyticsExpiryTbody.innerHTML = "";

  const today = new Date();
  const horizon = addDays(today, COMP_EXPIRY_HORIZON_DAYS);

  // Load ALL weeks (or at least enough history to cover 12 months back + uses)
  // For watertight accuracy, load full history like analytics does.
  const { data: allWeeks, error } = await supabase
    .from("roster_weeks")
    .select("id, week_ending, data")
    .eq("link", currentLink)
    .order("week_ending", { ascending: true });

  if (error) {
    console.error("refreshExpiryWatch error", error);
    return;
  }

  // Use the SAME ledger logic as the leave page
  const compBank = computeCompBankFromWeeks(allWeeks || [], today);

  // Build expiry stats from remaining valid credits
  const rows = [];

  Object.entries(compBank || {}).forEach(([name, rec]) => {
    const validDates = (rec.validCreditDates || []).slice(); // earn dates for unspent credits
    if (!validDates.length) return;

    // Convert earn dates -> expiry dates and check horizon
    const expiring = validDates
      .map((earnDate) => {
        const expiry = new Date(earnDate.getTime());
        expiry.setFullYear(expiry.getFullYear() + 1);
        return { earnDate, expiry };
      })
      .filter((x) => x.expiry >= today && x.expiry <= horizon)
      .sort((a, b) => a.expiry - b.expiry);

    if (!expiring.length) return;

   rows.push({
  name,
  expiringCount: expiring.length,
  firstExpiry: expiring[0].expiry,
  firstEarn: expiring[0].earnDate
});
  });

  rows.sort(
    (a, b) => a.firstExpiry - b.firstExpiry || a.name.localeCompare(b.name)
  );

  renderExpiryAnalytics(rows);
}

// THIS FUNCTION IS DEAD DO NOT USE
    function computeExpiryFromWeeks(weeks) {
      const usageMap = {};
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      weeks.forEach((w) => {
        const struct = w.data;
        if (!struct || !Array.isArray(struct.sections)) return;

        struct.sections.forEach((section) => {
          (section.rows || []).forEach((row) => {
            const staffName = (row.staff_name || "").trim();
            if (!staffName) return;

            if (!usageMap[staffName]) {
              usageMap[staffName] = {
                name: staffName,
                lropEarned: [],
                clUsedCount: 0
              };
            }

            days.forEach((day) => {
              const shift = row.shifts?.[day];
              const v = (shift || "").toUpperCase();
              const tags = Array.isArray(row.tags?.[day]) ? row.tags[day] : [];
              const tagSet = new Set(tags.map((t) => String(t).toUpperCase()));
              if (!v && tagSet.size === 0) return;

              const hasCL = tagSet.has("CL") || v.includes("C/L");
              const hasLROP = tagSet.has("LROP") || v.includes("LROP");

              const dayDate = getDateForDay(w.week_ending, day);

              if (hasCL) {
                usageMap[staffName].clUsedCount++;
              }
              if (hasLROP && dayDate) {
                usageMap[staffName].lropEarned.push(dayDate);
              }
            });
          });
        });
      });

      const today = new Date();
      const horizon = addDays(today, COMP_EXPIRY_HORIZON_DAYS);

      const result = [];

      Object.values(usageMap).forEach((u) => {
        const credits = [...u.lropEarned].sort((a, b) => a - b);
        let remainingCredits = credits.map((d) => ({ date: d, consumed: false }));

        let used = u.clUsedCount || 0;
        for (let i = 0; i < remainingCredits.length && used > 0; i++) {
          if (!remainingCredits[i].consumed) {
            remainingCredits[i].consumed = true;
            used--;
          }
        }

        let expiringCount = 0;
        let firstExpiry = null;

        remainingCredits.forEach((c) => {
          if (c.consumed) return;
          const expiry = new Date(c.date.getTime());
          expiry.setFullYear(expiry.getFullYear() + 1);

          if (expiry >= today && expiry <= horizon) {
            expiringCount++;
            if (!firstExpiry || expiry < firstExpiry) {
              firstExpiry = expiry;
            }
          }
        });

        if (expiringCount > 0) {
          result.push({
            name: u.name,
            expiringCount,
            firstExpiry
          });
        }
      });

      result.sort((a, b) => a.firstExpiry - b.firstExpiry || a.name.localeCompare(b.name));
      return result;
    }

    function renderExpiryAnalytics(rows) {
  analyticsExpiryTbody.innerHTML = "";

  if (!rows || !rows.length) {
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="4" class="muted" style="text-align:left;">No C/L credits expiring within the next ${COMP_EXPIRY_HORIZON_DAYS} days.</td>`;
    analyticsExpiryTbody.appendChild(tr);
    return;
  }

  rows.forEach((r) => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td style="text-align:left;">${r.name}</td>
      <td>${r.expiringCount}</td>
      <td>${formatUK(r.firstExpiry.toISOString())}</td>
      <td>${r.firstEarn ? formatUK(r.firstEarn.toISOString()) : ""}</td>
    `;
    analyticsExpiryTbody.appendChild(tr);
  });
}

})();
  </script>
</body>
</html>
