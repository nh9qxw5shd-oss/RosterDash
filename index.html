<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Control Roster</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Supabase JS CDN -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <style>
    /* ===== Global layout ===== */
    html, body {
      width: 100%;
      max-width: 100%;
      margin: 0;
      padding: 0;
      overflow-x: auto;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #d8dce3;
      color: #0f172a;
    }

    header {
      padding: 0.75rem 1rem;
      background: #f5f6f8;
      border-bottom: 1px solid #b8bfc9;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    header h1 {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 600;
      color: #0f172a;
    }
    header span {
      font-size: 0.85rem;
      color: #475569;
    }

    .container {
      padding: 0.75rem 1rem;
      max-width: 100%;
      width: 100%;
      margin: 0;
    }

    .card {
      background: #f2f3f5;
      border-radius: 0.75rem;
      border: 1px solid #b8bfc9;
      padding: 1rem 1.25rem;
      margin-bottom: 1rem;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
    }
    .card h2 {
      margin: 0 0 0.5rem;
      font-size: 1rem;
      color: #0f172a;
    }
    .muted {
      color: #475569;
      font-size: 0.8rem;
    }

    /* ===== Buttons ===== */
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.45rem 0.8rem;
      border-radius: 999px;
      border: 1px solid #b8bfc9;
      background: #e2e6eb;
      color: #0f172a;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease;
    }
    .btn:hover {
      background: #d5d9e2;
      border-color: #aeb6c4;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.12);
    }
    .btn-primary {
      border-color: #2563eb;
      background: #3b82f6;
      color: #ffffff;
    }
    .btn-primary:hover {
      background: #2563eb;
      border-color: #1d4ed8;
    }
    .btn-danger {
      border-color: #dc2626;
      background: #ef4444;
      color: #ffffff;
    }
    .btn-sm {
      padding: 0.25rem 0.6rem;
      font-size: 0.7rem;
    }

    /* Tag tray buttons */
    .tag-tray-btn-active {
      background: #1f2937;
      color: #f9fafb;
      border-color: #111827;
    }

    /* ===== Inputs & selects ===== */
    input, select, textarea {
      background: #f3f4f6;
      border-radius: 0.4rem;
      border: 1px solid #b8bfc9;
      color: #0f172a;
      padding: 0.35rem 0.55rem;
      font-size: 0.8rem;
      box-sizing: border-box;
    }
    input::placeholder {
      color: #9ca3af;
    }
    input:focus, select:focus, textarea:focus {
      outline: 2px solid #3b82f6;
      outline-offset: 1px;
      border-color: #3b82f6;
    }

    /* ===== Table / roster area ===== */
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.8rem;
      background: #e3e6ee; /* darker so it stands out from card */
    }
    th, td {
      border: 1px solid #b8bfc9;
      padding: 0.3rem 0.4rem;
      text-align: center;
      vertical-align: top;
    }
    thead {
      background: #d3d7e0; /* a shade darker than before */
      position: sticky;
      top: 0;
      z-index: 2;
    }
    thead th {
      font-weight: 600;
      color: #0f172a;
    }

    .roster-grid {
      max-width: 100%;
      width: 100%;
      max-height: 70vh;
      overflow-y: auto;
      overflow-x: auto;
      margin-top: 0.5rem;
      background: #eef0f3;
      border-radius: 0.5rem;
      border: 1px solid #c4c9d2;
      padding: 0.25rem;
    }

    /* Horizontal scroll helper for wide tables */
    .table-scroll-x {
      width: 100%;
      overflow-x: auto;
    }

    /* Tight name & remarks columns */
    .roster-grid table th:first-child,
    .roster-grid table td:first-child {
      width: 130px;
      max-width: 130px;
    }

    .roster-grid table th:last-child,
    .roster-grid table td:last-child {
      width: 160px;
      max-width: 160px;
    }

    /* Name input: clamp horizontally, ellipsis if too long */
    .roster-grid table td:first-child input {
      width: 100%;
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Remarks: allow vertical growth */
    .remark-input {
      width: 100%;
      font-size: 0.75rem;
      min-height: 1.6rem;
      resize: vertical;
      box-sizing: border-box;
    }

    /* ===== Desktop roster sizing ===== */
    .roster-grid table.roster-table {
      table-layout: fixed;
    }

    .roster-grid table.roster-table th,
    .roster-grid table.roster-table td {
      padding: 0.25rem 0.3rem;
      font-size: 0.78rem;
    }

    .roster-grid table.roster-table th:nth-child(1),
    .roster-grid table.roster-table td:nth-child(1) {
      width: 180px;
      max-width: 180px;
    }

    .roster-grid table.roster-table th:nth-child(2),
    .roster-grid table.roster-table td:nth-child(2),
    .roster-grid table.roster-table th:nth-child(3),
    .roster-grid table.roster-table td:nth-child(3),
    .roster-grid table.roster-table th:nth-child(4),
    .roster-grid table.roster-table td:nth-child(4),
    .roster-grid table.roster-table th:nth-child(5),
    .roster-grid table.roster-table td:nth-child(5),
    .roster-grid table.roster-table th:nth-child(6),
    .roster-grid table.roster-table td:nth-child(6),
    .roster-grid table.roster-table th:nth-child(7),
    .roster-grid table.roster-table td:nth-child(7),
    .roster-grid table.roster-table th:nth-child(8),
    .roster-grid table.roster-table td:nth-child(8) {
      width: 70px;
      max-width: 70px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .roster-grid table.roster-table th:nth-child(9),
    .roster-grid table.roster-table td:nth-child(9) {
      width: 220px;
      max-width: 220px;
    }

    /* ===== Shift cell layout ===== */
    .shift-cell-wrap {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.3rem; /* increased gap for more room under shifts */
    }

    .shift-input {
      flex: 1;
      min-width: 0;
      background: #ffffff;
      font-weight: 700;
      color: #000000 !important;
      font-size: 0.8rem;
    }

    /* Tag row under each shift */
    .tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.15rem;
    }
    .tag-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 0.05rem 0.35rem;
      font-size: 0.6rem;
      border: 1px solid #cbd5e1;
      background: #f3f4f6;
      color: #475569;
      white-space: nowrap;
    }
    .tag-pill-rdw {
      background: #2c2cd9;
      border-color: #2c2cd9;
      color: #ffffff;
      font-weight: 700;
    }
    .tag-pill-al {
      background: #ff0000;
      border-color: #b91c1c;
      color: #ffffff;
      font-weight: 700;
    }
    .tag-pill-cl {
      background: #f97316;
      border-color: #ea580c;
      color: #ffffff;
      font-weight: 700;
    }
    .tag-pill-sick {
      background: #4d7c0f;
      border-color: #3f6212;
      color: #ffffff;
      font-weight: 700;
    }
    .tag-pill-bo {
      background: #991b1b;
      border-color: #7f1d1d;
      color: #ffffff;
      font-weight: 700;
    }
    .tag-pill-rop {
      background: #c4b5fd;
      border-color: #a855f7;
      color: #312e81;
      font-weight: 700;
    }
    .tag-pill-hgd {
      background: #e5e7eb;
      border-color: #9ca3af;
      color: #111827;
    }

    /* ===== Conditional formatting ===== */
    .shift-day {
      background: #f1a983;
      color: #7c2d12;
    }
    .shift-night {
      background: #4d93d9;
      color: #1e3a8a;
    }
    .shift-spare {
      background: #d86dcd;
      color: #701a75;
    }
    .shift-oo {
      background: #ffff00;
      color: #854d0e;
    }
.shift-12oc {
  background: #b5b5b5;
  color: #000000 !important;
}
    .shift-al {
      background: #ff0000;
      color: #ffffff !important;
      text-decoration: line-through;
    }
    .shift-cl {
      background: #ff0000;
      color: #ffffff !important;
      text-decoration: line-through;
    }
    .shift-sick {
      background: #4d7c0f;
      color: #ffffff !important;
      text-decoration: line-through;
    }
    .shift-rd {
      background: #f3f4f6;
      color: #6b7280;
      font-style: italic;
    }
    .shift-bo {
      background: #ff0000;
      color: #ffffff !important;
      text-decoration: line-through;
    }
    .shift-rop {
      font-weight: 900;
    }

    /* Spare-origin marker (originally SPARE in base roster) */
    .spare-origin-cell {
      position: relative;
    }
    .spare-origin-cell::before {
      content: "";
      position: absolute;
      left: 2px;
      top: 2px;
      bottom: 2px;
      width: 4px;
      border-radius: 999px;
      background: #d86dcd;
      pointer-events: none;
    }

    /* Tags and status pills */
    .tag {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 0.15rem 0.4rem;
      font-size: 0.7rem;
      border: 1px solid #cbd2dd;
      color: #4b5563;
      background: #eef0f3;
    }
    .status-pill {
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid #b8bfc9;
      background: #f2f3f5;
    }
    .status-draft {
      border-color: #f59e0b;
      color: #92400e;
      background: #fffbeb;
    }
    .status-published {
      border-color: #22c55e;
      color: #15803d;
      background: #ecfdf3;
    }

    /* Layout helpers */
    .flex {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .flex-between {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .mt-1 { margin-top: 0.25rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 0.75rem; }
    .mb-1 { margin-bottom: 0.25rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .w-100 { width: 100%; }
    .hidden { display: none; }

    /* Alt row shading for per-person totals */
    #analytics-usage-tbody tr:nth-child(even),
    #analytics-leave-tbody tr:nth-child(even),
    #analytics-expiry-tbody tr:nth-child(even) {
      background: #e5e7eb;
    }

    /* Coverage banner styling */
    .coverage-panel {
      background: #e0f2fe;
      border-radius: 0.5rem;
      border: 1px solid #bae6fd;
      padding: 0.35rem 0.6rem;
      font-size: 0.8rem;
      color: #0f172a;
    }
    .coverage-top-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .coverage-pill {
      border-radius: 999px;
      padding: 0.15rem 0.6rem;
      font-size: 0.75rem;
      border: 1px solid transparent;
      font-weight: 600;
      white-space: nowrap;
    }
    .coverage-pill.cov-good {
      background: #dcfce7;
      border-color: #22c55e;
      color: #166534;
    }
    .coverage-pill.cov-amber {
      background: #fef9c3;
      border-color: #facc15;
      color: #854d0e;
    }
    .coverage-pill.cov-red {
      background: #fee2e2;
      border-color: #ef4444;
      color: #991b1b;
    }
    .coverage-summary-text {
      font-size: 0.8rem;
      color: #0f172a;
    }
    .coverage-legend {
      margin-top: 0.35rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: #475569;
    }
    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }
    .legend-swatch {
      width: 0.75rem;
      height: 0.75rem;
      border-radius: 0.2rem;
      border: 1px solid #cbd5e1;
    }

    /* Leave allowance RAG pills */
    .leave-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 3.2rem;
      padding: 0.1rem 0.45rem;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid transparent;
      white-space: nowrap;
    }
    .leave-green {
      background: #dcfce7;
      border-color: #22c55e;
      color: #166534;
    }
    .leave-amber {
      background: #fef9c3;
      border-color: #facc15;
      color: #854d0e;
    }
    .leave-red {
      background: #fee2e2;
      border-color: #ef4444;
      color: #991b1b;
    }

    /* Highlight current day column: soft blue ring around inputs */
    .today-col input {
      box-shadow: 0 0 0 2px #93c5fd;
      border-color: #3b82f6;
    }

    /* ===== Mobile-optimised roster table ===== */
    @media (max-width: 768px) {
      .roster-grid {
        max-height: 65vh;
        overflow-x: auto;
        overflow-y: auto;
      }

      .roster-grid table.roster-table th,
      .roster-grid table.roster-table td {
        padding: 0.15rem 0.2rem;
        font-size: 0.7rem;
      }

      .roster-grid table.roster-table input.shift-input {
        font-size: 0.7rem;
        padding: 0.2rem 0.25rem;
      }

      .roster-grid table.roster-table {
        table-layout: fixed;
      }

      .roster-grid table.roster-table th:nth-child(1),
      .roster-grid table.roster-table td:nth-child(1) {
        width: 110px;
      }

      .roster-grid table.roster-table th:nth-child(2),
      .roster-grid table.roster-table th:nth-child(3),
      .roster-grid table.roster-table th:nth-child(4),
      .roster-grid table.roster-table th:nth-child(5),
      .roster-grid table.roster-table th:nth-child(6),
      .roster-grid table.roster-table th:nth-child(7),
      .roster-grid table.roster-table th:nth-child(8),
      .roster-grid table.roster-table td:nth-child(2),
      .roster-grid table.roster-table td:nth-child(3),
      .roster-grid table.roster-table td:nth-child(4),
      .roster-grid table.roster-table td:nth-child(5),
      .roster-grid table.roster-table td:nth-child(6),
      .roster-grid table.roster-table td:nth-child(7),
      .roster-grid table.roster-table td:nth-child(8) {
        width: 52px;
      }

      .roster-grid table.roster-table th:nth-child(9),
      .roster-grid table.roster-table td:nth-child(9) {
        display: none;
      }
    }

    /* Leave details expansion */
    .leave-toggle {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 0.8rem;
      padding: 0;
      margin-right: 0.25rem;
    }
    .leave-detail-row td {
      text-align: left;
      font-size: 0.75rem;
      background: #edf0f5;
    }
    .leave-detail-block h4 {
      margin: 0.1rem 0;
      font-size: 0.78rem;
    }
    .leave-detail-block ul {
      margin: 0.1rem 0 0.4rem 1rem;
      padding: 0;
    }

    /* ===== Roster weeks hierarchy ===== */
    .weeks-year-row td {
      background: #e5e7eb;
      font-weight: 600;
      text-align: left;
      font-size: 0.85rem;
    }

    .weeks-month-row td {
      background: #f3f4f6;
      text-align: left;
      padding-left: 1.75rem;
      font-weight: 500;
      font-size: 0.8rem;
    }

    .weeks-week-row td {
      background: #ffffff;
    }

    .weeks-toggle {
      border: none;
      background: transparent;
      cursor: pointer;
      margin-right: 0.35rem;
      font-size: 0.8rem;
    }

    .weeks-year-row.collapsed td,
    .weeks-month-row.collapsed td {
      opacity: 0.85;
    }

    /* Print styling */
    @media print {
      body {
        background: #ffffff;
      }
      .no-print {
        display: none !important;
      }
      header {
        display: none !important;
      }
      #editor-card {
        border: none;
        box-shadow: none;
        padding: 0;
        margin: 0;
      }
      .container {
        padding: 0;
        margin: 0;
      }
      .roster-grid {
        max-height: none;
        overflow: visible;
        border: none;
        padding: 0;
        background: #ffffff;
      }
      table {
        page-break-inside: avoid;
      }
    }
  </style>
</head>
<body>
 <header class="no-print">
  <div>
    <h1>Control Roster</h1>
    <span>GitHub-hosted • Supabase-backed • Excel finally retired</span>
  </div>
  <div class="flex">
    <span id="user-info" class="muted">Not signed in</span>
    <button id="btn-signout" class="btn btn-sm hidden">Sign out</button>
    <a href="template-admin.html" id="link-template-admin" class="btn btn-sm hidden">Template admin</a>
  </div>
</header>

  <div class="container">

    <!-- Auth card -->
    <div id="auth-card" class="card no-print">
      <h2>Sign in</h2>
      <p class="muted">Use your Supabase email/password account to manage rosters.</p>
      <form id="auth-form" class="flex mt-2">
        <input type="email" id="auth-email" placeholder="Email" required />
        <input type="password" id="auth-password" placeholder="Password" required />
        <button type="submit" class="btn btn-primary">Sign in</button>
      </form>
      <div class="mt-2">
        <button id="btn-viewer" class="btn btn-sm">
          View roster read-only
        </button>
      </div>
      <p id="auth-error" class="muted mt-2"></p>
    </div>

    <!-- Main app -->
    <div id="app" class="hidden">

      <!-- Week list -->
      <div class="card no-print">
        <div class="flex-between">
  <div>
    <h2>Roster weeks</h2>
    <p class="muted">Draft & published rosters, one record per week ending.</p>
  </div>
  <div class="flex">
    <label class="muted" style="font-size:0.75rem;display:flex;align-items:center;gap:0.25rem;">
      Link:
      <select id="link-selector">
        <option value="CTRL">Control</option>
        <option value="SNDM">SNDM</option>
      </select>
    </label>
    <input type="date" id="new-week-date" />
    <select id="new-week-template">
      <option value="">Template…</option>
    </select>
    <button id="btn-create-week" class="btn btn-primary">New draft from template</button>
  </div>
</div>
        <div class="mt-2 table-scroll-x">
          <table id="weeks-table">
            <thead>
              <tr>
                <th>Week ending</th>
                <th>Label</th>
                <th>Status</th>
                <th>Template</th>
                <th>Coverage</th>
                <th>Published at</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="weeks-tbody"></tbody>
          </table>
        </div>
      </div>

      <!-- Analytics card -->
      <div id="analytics-card" class="card no-print">
        <div class="flex-between">
          <div>
            <h2>Analytics</h2>
            <p class="muted">
              Annual totals for RDW, leave, sickness & uncovered shifts across all links.
            </p>
          </div>
          <div class="flex">
            <select id="analytics-year"></select>
            <button id="btn-refresh-analytics" class="btn btn-sm">Refresh</button>
            <button id="btn-toggle-analytics" class="btn btn-sm">Show</button>
          </div>
        </div>

        <div id="analytics-body">
          <!-- Weekly trends -->
          <div class="mt-2">
            <h3 style="margin:0 0 0.25rem;font-size:0.9rem;color:#0f172a;">Weekly trends</h3>
            <p class="muted mb-1">One row per roster week in the selected calendar year.</p>
            <table>
              <thead>
                <tr>
                  <th>Week ending</th>
                  <th>A/L days</th>
                  <th>C/L days</th>
                  <th>Sick days</th>
                  <th>RDW (all)</th>
                  <th>RDW (Sun)</th>
                  <th>Uncovered shifts</th>
                </tr>
              </thead>
              <tbody id="analytics-weekly-tbody"></tbody>
            </table>
          </div>

          <!-- Per-person usage -->
          <div class="mt-3">
            <h3 style="margin:0 0 0.25rem;font-size:0.9rem;color:#0f172a;">Per-person usage</h3>
            <div class="flex-between mb-1">
              <p class="muted mb-1">
                Calendar year totals per staff member (based on roster data).
              </p>
              <input
                id="usage-filter"
                type="text"
                placeholder="Filter by name…"
                style="max-width: 220px;"
              />
            </div>
            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>A/L days</th>
                  <th>C/L days</th>
                  <th>RDW (all)</th>
                  <th>RDW (Sun)</th>
                </tr>
              </thead>
              <tbody id="analytics-usage-tbody"></tbody>
            </table>
          </div>

          <!-- Leave allowances -->
          <div class="mt-3">
            <h3 style="margin:0 0 0.25rem;font-size:0.9rem;color:#0f172a;">Leave allowances</h3>
            <p class="muted mb-1">
              A/L uses a fixed annual allowance. C/L allowance is a live bank of usable LROP-earned days
              (12-month validity, minus days already taken).
            </p>
            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>A/L used</th>
                  <th>A/L allowance</th>
                  <th>A/L %</th>
                  <th>
                    C/L used<br/>
                    <span class="muted" style="font-size:0.7rem;">(used in last 12 months)</span>
                  </th>
                  <th>
                    C/L usable balance<br/>
                    <span class="muted" style="font-size:0.7rem;">(valid, unspent credits)</span>
                  </th>
                </tr>
              </thead>
              <tbody id="analytics-leave-tbody"></tbody>
            </table>
            <div class="mt-1 flex-between">
              <button id="btn-save-allowances" class="btn btn-sm">Save leave allowances</button>
              <span id="leave-save-status" class="muted"></span>
            </div>
          </div>

          <!-- Comp leave expiry watch -->
          <div class="mt-3">
            <h3 style="margin:0 0 0.25rem;font-size:0.9rem;color:#0f172a;">Comp leave expiry watch</h3>
            <p class="muted mb-1">
              LROP-earned C/L credits that will expire in the next 60 days (1-year validity from date earned).
            </p>
            <table>
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Credits expiring</th>
                  <th>First expiry date</th>
                </tr>
              </thead>
              <tbody id="analytics-expiry-tbody"></tbody>
            </table>
          </div>
        </div>
</div>

      <!-- Shift market -->
      <div id="shift-market-card" class="card no-print">
        <div class="flex-between">
          <div>
            <h2>Shift market</h2>
            <p class="muted">
              Uncovered published shifts from the current week onwards. Staff can register interest;
              rankings are based on RDW usage (Sunday RDW if the shift is on a Sunday).
            </p>
          </div>
          <div class="flex">
            <button id="btn-toggle-shift-market" class="btn btn-sm">Show</button>
          </div>
        </div>
        <div id="shift-market-body" class="hidden mt-2">
          <p class="muted mb-1">
            Each row is an uncovered slot from a published roster. Use the selector to register interest
            against your name. Rankings are not an allocation decision, just a transparent view.
          </p>
         <div class="table-scroll-x">
  <table>
    <thead>
      <tr>
        <th>Status</th>
        <th>Week ending</th>
        <th>Date</th>
        <th>Section</th>
        <th>Shift</th>
        <th>Interest</th>
      </tr>
    </thead>
    <tbody id="shift-market-tbody"></tbody>
  </table>
</div>
        </div>
      </div>
      </div>

      <!-- Roster editor -->
      <div id="editor-card" class="card">
        <div class="flex-between">
          <div>
            <h2 id="editor-title">Week editor</h2>
            <p id="editor-subtitle" class="muted"></p>
          </div>
         <div class="flex no-print">
  <span id="editor-status-pill" class="status-pill"></span>
  <button id="btn-save-week" class="btn btn-primary btn-sm">Save draft</button>
  <button id="btn-publish-week" class="btn btn-sm">Publish</button>
  <button id="btn-change-log" class="btn btn-sm">Change log</button>
  <label class="muted" style="display:flex;align-items:center;gap:0.25rem;font-size:0.75rem;">
    <input type="checkbox" id="toggle-readonly" />
    Read-only
  </label>
  <button id="btn-print-week" class="btn btn-sm">Print / PDF</button>
</div>
        </div>
        <!-- Per-week roster filter -->
        <div class="mt-2 no-print" style="max-width:260px;">
          <input
            id="roster-filter"
            type="text"
            placeholder="Filter this week by name…"
            style="width:100%;"
          />
        </div>

        <!-- Coverage / legend panel -->
        <div id="coverage-banner" class="coverage-panel mt-1">
          <div class="coverage-top-row">
            <span id="coverage-pill" class="coverage-pill">
              Coverage: n/a
            </span>
            <span id="coverage-summary" class="coverage-summary-text">
              No metrics available yet.
            </span>
          </div>
          <div class="coverage-legend">
            <span class="legend-item">
              <span class="legend-swatch" style="background:#f1a983;"></span> Day
            </span>
            <span class="legend-item">
              <span class="legend-swatch" style="background:#4d93d9;"></span> Night
            </span>
            <span class="legend-item">
              <span class="legend-swatch" style="background:#d86dcd;"></span> Spare
            </span>
            <span class="legend-item">
              <span class="legend-swatch" style="background:#ff0000;"></span> A/L &amp; B.O
            </span>
            <span class="legend-item">
              <span class="legend-swatch" style="background:#4d7c0f;"></span> Sick
            </span>
            <span class="legend-item">
              <span class="legend-swatch" style="background:#f3f4f6;"></span> RD
            </span>
          </div>
        </div>

        <!-- Tag tray (admin only) -->
        <div id="tag-tray" class="mt-2 no-print flex" style="align-items:center;flex-wrap:wrap;">
          <span class="muted" style="font-size:0.75rem;">Tag mode:</span>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="RDW">RDW</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="AL">A/L</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="CL">C/L</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="LROP">LROP</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="HROP">HROP</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="BO">B.O</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="SICK">Sick</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="HGD">HGD</button>
          <button type="button" class="btn btn-sm tag-tray-btn" data-tag="CLEAR">Clear tags</button>
        </div>

        <div class="mt-2 roster-grid" id="roster-grid"></div>
      </div>
    </div>
  </div>

  <!-- Shared shift presets -->
  <datalist id="shift-presets">
    <option value="0600-1800"></option>
    <option value="0700-1900"></option>
    <option value="0630-1830"></option>
    <option value="1800-0600"></option>
    <option value="1830-0630"></option>
  </datalist>

  <script>
(() => {
    // ===== CONFIG =====
    const SUPABASE_URL = "https://ywvbxfitzsuyhvxcdnth.supabase.co";
    const SUPABASE_ANON_KEY =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl3dmJ4Zml0enN1eWh2eGNkbnRoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMyMzAwNTMsImV4cCI6MjA3ODgwNjA1M30.d-yN2C599j4BInhVt6QKDImhGGmiidIlOjuxAAnjVCM";

    const { createClient } = window.supabase;

     // Reuse client if script is evaluated more than once
  window.__sbClient = window.__sbClient || createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  const supabase = window.__sbClient;

    let currentUser = null;
    let currentProfile = null;
    let currentWeek = null;
    let isPublicViewer = false;
    let forceReadOnly = false;
    let currentLink = "CTRL";

    let lastUsageStats = [];
    let currentAnalyticsYear = null;

    let leaveAllowancesByName = {};
    const COMP_EXPIRY_HORIZON_DAYS = 60;

    // Active tag from the tray (e.g. "AL", "RDW", "CLEAR")
    let activeTag = null;

    // Tracks whether current roster has unsaved edits
    let hasUnsavedChanges = false;

    // ===== Date helpers =====
    function formatUK(dateStr) {
      if (!dateStr) return "";
      const d = new Date(dateStr);
      if (isNaN(d)) return dateStr;
      const day = String(d.getDate()).padStart(2, "0");
      const month = String(d.getMonth() + 1).padStart(2, "0");
      const year = d.getFullYear();
      return `${day}/${month}/${year}`;
    }

    function addDays(date, days) {
      const d = new Date(date.getTime());
      d.setDate(d.getDate() + days);
      return d;
    }

    function isEffectiveReadOnly() {
  const role = currentProfile?.role || "viewer";

  // Editor is read-only on draft weeks
  const isEditorLocked =
    role === "editor" &&
    currentWeek &&
    currentWeek.status === "draft";

  return (
    isPublicViewer ||
    role === "viewer" ||
    forceReadOnly ||
    isEditorLocked
  );
}

    // Given week-ending date and day key, get actual Date (week ending = Saturday)
    function getDateForDay(weekEndingStr, dayKey) {
      if (!weekEndingStr) return null;
      const end = new Date(weekEndingStr);
      if (isNaN(end)) return null;
      const offsets = {
        sun: -6,
        mon: -5,
        tue: -4,
        wed: -3,
        thu: -2,
        fri: -1,
        sat: 0
      };
      const offset = offsets[dayKey] ?? 0;
      const d = new Date(end.getTime());
      d.setDate(d.getDate() + offset);
      return d;
    }

    // ===== DOM HOOKS =====
    const authCard = document.getElementById("auth-card");
    const appEl = document.getElementById("app");
    const authForm = document.getElementById("auth-form");
    const authEmail = document.getElementById("auth-email");
    const authPassword = document.getElementById("auth-password");
    const authError = document.getElementById("auth-error");
    const userInfo = document.getElementById("user-info");
    const btnSignout = document.getElementById("btn-signout");
    const btnViewer = document.getElementById("btn-viewer");

    const newWeekTemplateSelect = document.getElementById("new-week-template");
    const weeksTbody = document.getElementById("weeks-tbody");
    const linkSelector = document.getElementById("link-selector");

    if (linkSelector) {
      linkSelector.addEventListener("change", async () => {
        if (!confirmDiscardChanges()) {
          // revert selector if user cancels
          linkSelector.value = currentLink;
          return;
        }
        currentLink = linkSelector.value || "CTRL";
        currentWeek = null;
        editorCard.classList.add("hidden");
        hasUnsavedChanges = false;

        await loadTemplates();
        await loadWeeks();
        await loadAnalyticsYears();
        await refreshAnalytics();
        await refreshExpiryWatch();
        await refreshShiftMarket();
      });
    }

    const newWeekDate = document.getElementById("new-week-date");
    const btnCreateWeek = document.getElementById("btn-create-week");

    const editorCard = document.getElementById("editor-card");
    const editorTitle = document.getElementById("editor-title");
    const editorSubtitle = document.getElementById("editor-subtitle");
    const editorStatusPill = document.getElementById("editor-status-pill");
    const rosterGrid = document.getElementById("roster-grid");
    const btnSaveWeek = document.getElementById("btn-save-week");
    const btnPublishWeek = document.getElementById("btn-publish-week");
    const btnPrintWeek = document.getElementById("btn-print-week");
    const readonlyToggle = document.getElementById("toggle-readonly");
    const rosterFilterInput = document.getElementById("roster-filter");
const btnChangeLog = document.getElementById("btn-change-log");


    const analyticsYearSelect = document.getElementById("analytics-year");
    const btnRefreshAnalytics = document.getElementById("btn-refresh-analytics");
    const btnToggleAnalytics = document.getElementById("btn-toggle-analytics");
    const analyticsBody = document.getElementById("analytics-body");
    const analyticsWeeklyTbody = document.getElementById("analytics-weekly-tbody");
    const analyticsUsageTbody = document.getElementById("analytics-usage-tbody");
    const analyticsLeaveTbody = document.getElementById("analytics-leave-tbody");
    const analyticsExpiryTbody = document.getElementById("analytics-expiry-tbody");
    const usageFilterInput = document.getElementById("usage-filter");
    const btnSaveAllowances = document.getElementById("btn-save-allowances");
    const leaveSaveStatus = document.getElementById("leave-save-status");

    const coveragePill = document.getElementById("coverage-pill");
    const coverageSummary = document.getElementById("coverage-summary");

    const tagTray = document.getElementById("tag-tray");

    const shiftMarketCard = document.getElementById("shift-market-card");
    const shiftMarketBody = document.getElementById("shift-market-body");
    const shiftMarketTbody = document.getElementById("shift-market-tbody");
    const btnToggleShiftMarket = document.getElementById("btn-toggle-shift-market");

    function syncTagTrayVisibility() {
      if (!tagTray) return;
      tagTray.style.display = isEffectiveReadOnly() ? "none" : "flex";
    }

    if (readonlyToggle) {
      readonlyToggle.addEventListener("change", () => {
        forceReadOnly = !!readonlyToggle.checked;
        syncTagTrayVisibility();
        if (currentWeek) {
          renderRosterGrid(currentWeek.data);
        }
      });
    }

    // Default analytics collapsed
    analyticsBody.classList.add("hidden");
    btnToggleAnalytics.textContent = "Show";

    // Default shift market collapsed
    if (shiftMarketBody && btnToggleShiftMarket) {
      shiftMarketBody.classList.add("hidden");
      btnToggleShiftMarket.textContent = "Show";
      btnToggleShiftMarket.addEventListener("click", () => {
        const collapsed = shiftMarketBody.classList.toggle("hidden");
        btnToggleShiftMarket.textContent = collapsed ? "Show" : "Hide";
      });
    }

    // ===== AUTH =====
    authForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      authError.textContent = "";
      const email = authEmail.value.trim();
      const password = authPassword.value;

      const { data, error } = await supabase.auth.signInWithPassword({ email, password });
      if (error) {
        authError.textContent = error.message;
        return;
      }
      currentUser = data.user;
      isPublicViewer = false;
      await loadProfile();
      await postLoginInit();
    });

      btnSignout.addEventListener("click", async () => {
      if (!confirmDiscardChanges()) return;

      await supabase.auth.signOut();
      currentUser = null;
      currentProfile = null;
      currentWeek = null;
      isPublicViewer = false;
      userInfo.textContent = "Not signed in";
      btnSignout.classList.add("hidden");
      authCard.classList.remove("hidden");
      appEl.classList.add("hidden");
      editorCard.classList.add("hidden");
    });

        btnViewer.addEventListener("click", async (e) => {
      e.preventDefault();

      if (!confirmDiscardChanges()) return;

      isPublicViewer = true;
      currentUser = null;
      currentProfile = { full_name: "Public viewer", role: "viewer" };

      userInfo.textContent = "Public viewer • read-only";
      btnSignout.classList.add("hidden");
      authCard.classList.add("hidden");
      appEl.classList.remove("hidden");

      newWeekDate.disabled = true;
      newWeekTemplateSelect.disabled = true;
      btnCreateWeek.disabled = true;

      syncTagTrayVisibility();

      await loadTemplates();
      await loadWeeks();
      await loadAnalyticsYears();
      await refreshAnalytics();
      await refreshExpiryWatch();
      await refreshShiftMarket();
    });

    async function loadProfile() {
      if (!currentUser) return;
      const { data, error } = await supabase
        .from("profiles")
        .select("*")
        .eq("id", currentUser.id)
        .single();

      if (!error) currentProfile = data;
    }

    async function postLoginInit() {
  const role = currentProfile?.role || "viewer";

  userInfo.textContent = currentProfile
    ? `${currentProfile.full_name || currentUser.email} • ${currentProfile.role}`
    : currentUser.email;

  isPublicViewer = false;
  btnSignout.classList.remove("hidden");

  // ✅ Show / hide Template Admin link based on role
  const templateAdminLink = document.getElementById("link-template-admin");
  if (templateAdminLink) {
    if (role === "admin") {
      templateAdminLink.classList.remove("hidden");
    } else {
      templateAdminLink.classList.add("hidden");
    }
  }

  authCard.classList.add("hidden");
  appEl.classList.remove("hidden");

  newWeekDate.disabled = false;
  newWeekTemplateSelect.disabled = false;
 btnCreateWeek.disabled = !(role === "admin");

  syncTagTrayVisibility();

  await loadTemplates();
  await loadWeeks();
  await loadAnalyticsYears();
  await refreshAnalytics();
  await refreshExpiryWatch();
  await refreshShiftMarket();
}

    (async function init() {
      const { data } = await supabase.auth.getSession();
      if (data.session) {
        currentUser = data.session.user;
        await loadProfile();
        await postLoginInit();
      } else {
        syncTagTrayVisibility();
      }
    })();

    // Tag tray behaviour
    if (tagTray) {
      const trayButtons = tagTray.querySelectorAll(".tag-tray-btn");
      trayButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          if (isEffectiveReadOnly()) return;
          const tag = btn.dataset.tag || null;
          if (activeTag === tag) {
            activeTag = null;
            trayButtons.forEach((b) => b.classList.remove("tag-tray-btn-active"));
          } else {
            activeTag = tag;
            trayButtons.forEach((b) => b.classList.remove("tag-tray-btn-active"));
            btn.classList.add("tag-tray-btn-active");
          }
        });
      });
    }

    // ===== TEMPLATES =====
    async function loadTemplates() {
            const { data, error } = await supabase
        .from("roster_templates")
        .select("id, name, code")
        .eq("link", currentLink)
        .order("code", { ascending: true });

      if (error) {
        console.error("loadTemplates error", error);
        return;
      }

      newWeekTemplateSelect.innerHTML = '<option value="">Template…</option>';
      for (const t of data) {
        const opt = document.createElement("option");
        opt.value = t.id;
        opt.textContent = `${t.code} – ${t.name}`;
        newWeekTemplateSelect.appendChild(opt);
      }
    }

    btnCreateWeek.addEventListener("click", async () => {
      if (!confirmDiscardChanges()) return;

      const role = currentProfile?.role || "viewer";
if (isPublicViewer || role !== "admin") {
  alert("You do not have permission to create weeks.");
  return;
}

      const dateStr = newWeekDate.value;
      const templateId = newWeekTemplateSelect.value;
      if (!dateStr || !templateId) {
        alert("Pick a week ending date and a template.");
        return;
      }

      const { data: tmpl, error: tmplErr } = await supabase
        .from("roster_templates")
        .select("id, name, code, structure")
        .eq("id", templateId)
        .single();

      if (tmplErr) {
        console.error(tmplErr);
        alert("Unable to load template.");
        return;
      }

      const label = `Week - Ending ${formatUK(dateStr)}`;
            const payload = {
        week_ending: dateStr,
        label,
        status: "draft",
        template_id: tmpl.id,
        data: tmpl.structure,
        link: currentLink
      };

      const { data, error } = await supabase
        .from("roster_weeks")
        .insert(payload)
        .select("*")
        .single();

      if (error) {
        console.error(error);
        alert("Error creating week.");
        return;
      }

      await loadWeeks();
      await openWeek(data);
      await loadAnalyticsYears();
      await refreshAnalytics();
      await refreshExpiryWatch();
    });

    // ===== WEEK LIST =====
       async function loadWeeks() {
            const { data, error } = await supabase
        .from("roster_weeks")
        .select(
          "id, week_ending, label, status, template_id, created_at, published_at, data, roster_templates(name, code)"
        )
        .eq("link", currentLink)
        .order("week_ending", { ascending: false });

      if (error) {
        console.error("loadWeeks error", error);
        return;
      }

      weeksTbody.innerHTML = "";
      if (!data || !data.length) return;

      // Group weeks -> year -> month
      const groups = {};
      data.forEach((w) => {
        if (!w.week_ending) return;
        const d = new Date(w.week_ending);
        if (isNaN(d)) return;
        const year = d.getFullYear();
        const monthIdx = d.getMonth(); // 0-11

        if (!groups[year]) groups[year] = {};
        if (!groups[year][monthIdx]) groups[year][monthIdx] = [];
        groups[year][monthIdx].push(w);
      });

      const today = new Date();
      const currentYearNum = today.getFullYear();
      const currentMonthNum = today.getMonth(); // 0-11

      const sortedYears = Object.keys(groups)
        .map(Number)
        .sort((a, b) => b - a); // latest year first

      sortedYears.forEach((year) => {
        // ==== Year row ====
        const yearTr = document.createElement("tr");
        yearTr.className = "weeks-year-row";
        yearTr.dataset.year = String(year);

        const yearTd = document.createElement("td");
        yearTd.colSpan = 7;
        yearTd.innerHTML = `
          <button
            type="button"
            class="weeks-toggle"
            data-level="year"
            data-year="${year}"
          >
            ▼
          </button>
          <strong>${year}</strong>
        `;
        yearTr.appendChild(yearTd);
        weeksTbody.appendChild(yearTr);

        // ==== Month rows ====
        const monthsObj = groups[year];
        const sortedMonths = Object.keys(monthsObj)
          .map(Number)
          .sort((a, b) => b - a); // latest month first

        sortedMonths.forEach((monthIdx) => {
          const monthName = new Date(year, monthIdx, 1).toLocaleString("en-GB", {
            month: "long",
          });

          const monthTr = document.createElement("tr");
          monthTr.className = "weeks-month-row";
          monthTr.dataset.year = String(year);
          monthTr.dataset.month = String(monthIdx);

          const monthTd = document.createElement("td");
          monthTd.colSpan = 7;
          monthTd.innerHTML = `
            <button
              type="button"
              class="weeks-toggle"
              data-level="month"
              data-year="${year}"
              data-month="${monthIdx}"
            >
              ▼
            </button>
            <span>${monthName}</span>
          `;
          monthTr.appendChild(monthTd);
          weeksTbody.appendChild(monthTr);

          // ==== Week rows ====
          monthsObj[monthIdx].forEach((w) => {
            const tr = document.createElement("tr");
            tr.className = "weeks-week-row";
            tr.dataset.year = String(year);
            tr.dataset.month = String(monthIdx);

            const tmplLabel = w.roster_templates
              ? `${w.roster_templates.code} – ${w.roster_templates.name}`
              : "N/A";

            const metrics = computeWeekMetrics(w);
            const hasGaps = metrics.uncovered > 0;

            const coverageCell = hasGaps
              ? `<span class="tag" style="border-color:#fbbf24;background:#fef9c3;color:#92400e;">⚠ Gaps</span>`
              : `<span class="tag" style="border-color:#22c55e;background:#ecfdf3;color:#166534;">✅ Full</span>`;

            tr.innerHTML = `
              <td>${formatUK(w.week_ending)}</td>
              <td>${w.label || ""}</td>
              <td>
                <span class="status-pill ${
                  w.status === "published" ? "status-published" : "status-draft"
                }">
                  ${w.status}
                </span>
              </td>
              <td>${tmplLabel}</td>
              <td>${coverageCell}</td>
              <td>${w.published_at ? formatUK(w.published_at) : ""}</td>
              <td>
                <button class="btn btn-sm btn-open-week" data-id="${w.id}">Open</button>
              </td>
            `;
            weeksTbody.appendChild(tr);
          });
        });
      });

      // Wire up the "Open" buttons as before
      document.querySelectorAll(".btn-open-week").forEach((btn) => {
        btn.addEventListener("click", async () => {
          if (!confirmDiscardChanges()) return;

          const id = btn.getAttribute("data-id");
          const { data, error } = await supabase
            .from("roster_weeks")
            .select("*")
            .eq("id", id)
            .single();

          if (error) {
            console.error(error);
            return;
          }
          await openWeek(data);
        });
      });

      // Apply initial collapse state & wire toggles
      applyInitialWeekCollapse(currentYearNum, currentMonthNum);
      wireWeekToggleHandlers();
    }

    function collapseYear(year) {
      const yStr = String(year);
      const yearRow = weeksTbody.querySelector(
        `.weeks-year-row[data-year="${yStr}"]`
      );
      if (yearRow) yearRow.classList.add("collapsed");

      // Hide months + weeks for this year
      weeksTbody
        .querySelectorAll(
          `.weeks-month-row[data-year="${yStr}"], .weeks-week-row[data-year="${yStr}"]`
        )
        .forEach((row) => {
          row.style.display = "none";
        });

      const btn = weeksTbody.querySelector(
        `.weeks-toggle[data-level="year"][data-year="${yStr}"]`
      );
      if (btn) btn.textContent = "▶";
      return true;
    }

    function expandYear(year) {
      const yStr = String(year);
      const yearRow = weeksTbody.querySelector(
        `.weeks-year-row[data-year="${yStr}"]`
      );
      if (yearRow) yearRow.classList.remove("collapsed");

      // Show month headers; week rows controlled by their month collapse state
      weeksTbody
        .querySelectorAll(`.weeks-month-row[data-year="${yStr}"]`)
        .forEach((row) => {
          row.style.display = "";
        });

      const btn = weeksTbody.querySelector(
        `.weeks-toggle[data-level="year"][data-year="${yStr}"]`
      );
      if (btn) btn.textContent = "▼";
      return false;
    }

    function toggleYear(year) {
      const yStr = String(year);
      const yearRow = weeksTbody.querySelector(
        `.weeks-year-row[data-year="${yStr}"]`
      );
      const collapsed = yearRow?.classList.contains("collapsed");
      if (collapsed) {
        return expandYear(year);
      } else {
        return collapseYear(year);
      }
    }

    function collapseMonth(year, monthIdx) {
      const yStr = String(year);
      const mStr = String(monthIdx);
      const monthRow = weeksTbody.querySelector(
        `.weeks-month-row[data-year="${yStr}"][data-month="${mStr}"]`
      );
      if (monthRow) monthRow.classList.add("collapsed");

      weeksTbody
        .querySelectorAll(
          `.weeks-week-row[data-year="${yStr}"][data-month="${mStr}"]`
        )
        .forEach((row) => {
          row.style.display = "none";
        });

      const btn = weeksTbody.querySelector(
        `.weeks-toggle[data-level="month"][data-year="${yStr}"][data-month="${mStr}"]`
      );
      if (btn) btn.textContent = "▶";
      return true;
    }

    function expandMonth(year, monthIdx) {
      const yStr = String(year);
      const mStr = String(monthIdx);
      const monthRow = weeksTbody.querySelector(
        `.weeks-month-row[data-year="${yStr}"][data-month="${mStr}"]`
      );
      if (monthRow) monthRow.classList.remove("collapsed");

      weeksTbody
        .querySelectorAll(
          `.weeks-week-row[data-year="${yStr}"][data-month="${mStr}"]`
        )
        .forEach((row) => {
          row.style.display = "";
        });

      const btn = weeksTbody.querySelector(
        `.weeks-toggle[data-level="month"][data-year="${yStr}"][data-month="${mStr}"]`
      );
      if (btn) btn.textContent = "▼";
      return false;
    }

    function toggleMonth(year, monthIdx) {
      const yStr = String(year);
      const mStr = String(monthIdx);
      const monthRow = weeksTbody.querySelector(
        `.weeks-month-row[data-year="${yStr}"][data-month="${mStr}"]`
      );
      const collapsed = monthRow?.classList.contains("collapsed");
      if (collapsed) {
        return expandMonth(year, monthIdx);
      } else {
        return collapseMonth(year, monthIdx);
      }
    }

function shouldAutoExpandMonth(year, monthIdx) {
  const now = new Date();
  const curKey = now.getFullYear() * 12 + now.getMonth();
  const nextKey = curKey + 1;

  const targetKey = year * 12 + monthIdx;
  return targetKey === curKey || targetKey === nextKey;
}

    function applyInitialWeekCollapse(currentYear, currentMonth) {
  // Default: everything visible
  weeksTbody
    .querySelectorAll(".weeks-year-row, .weeks-month-row, .weeks-week-row")
    .forEach((row) => {
      row.style.display = "";
    });

  const yearRows = weeksTbody.querySelectorAll(".weeks-year-row");
  yearRows.forEach((yrRow) => {
    const year = Number(yrRow.dataset.year);

    // Collapse all years before current year
    if (year < currentYear) {
      collapseYear(year);
      return;
    }

    // Keep current/future years expanded at year level (so month headers visible)
    expandYear(year);

    const monthRows = weeksTbody.querySelectorAll(
      `.weeks-month-row[data-year="${year}"]`
    );

    monthRows.forEach((mRow) => {
      const monthIdx = Number(mRow.dataset.month);

      // Always show the month header row (it’s the clickable control)
      mRow.style.display = "";

      // Only auto-expand current month + next month. Everything else collapsed.
      if (shouldAutoExpandMonth(year, monthIdx)) {
        expandMonth(year, monthIdx);
      } else {
        collapseMonth(year, monthIdx);
      }
    });
  });
}

    function wireWeekToggleHandlers() {
      weeksTbody.querySelectorAll(".weeks-toggle").forEach((btn) => {
        btn.addEventListener("click", () => {
          const level = btn.dataset.level;
          const year = Number(btn.dataset.year);
          const month =
            btn.dataset.month !== undefined
              ? Number(btn.dataset.month)
              : null;

          if (level === "year") {
            toggleYear(year);
          } else if (level === "month" && month !== null) {
            toggleMonth(year, month);
          }
        });
      });
    }

    // Mark which cells were originally SPARE in the base roster
    function ensureSpareOrigin(struct) {
      if (!struct || !Array.isArray(struct.sections)) return;
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      struct.sections.forEach((section) => {
        (section.rows || []).forEach((row) => {
          if (!row.spare_origin) row.spare_origin = {};
          days.forEach((day) => {
            if (typeof row.spare_origin[day] === "boolean") return;
            const v = (row.shifts && row.shifts[day])
              ? String(row.shifts[day]).toUpperCase()
              : "";
            row.spare_origin[day] = v.includes("SPARE");
          });
        });
      });
    }

    function ensureRowTags(row) {
      if (!row.tags) row.tags = {};
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
      days.forEach((day) => {
        if (!Array.isArray(row.tags[day])) {
          row.tags[day] = [];
        }
      });
    }

    async function openWeek(weekRow) {
      currentWeek = weekRow;
      ensureSpareOrigin(currentWeek.data);

      editorCard.classList.remove("hidden");
      editorTitle.textContent = `Week ending ${formatUK(weekRow.week_ending)}`;
      editorSubtitle.textContent = weekRow.label || "";
      setStatusPill(weekRow.status);
      syncTagTrayVisibility();
      renderRosterGrid(weekRow.data);
      syncEditorButtons();
      updateCoverageBanner();

      // Opening a week is a clean baseline
      hasUnsavedChanges = false;
    }

    function setStatusPill(status) {
      editorStatusPill.textContent = status;
      editorStatusPill.classList.remove("status-draft", "status-published");
      editorStatusPill.classList.add(status === "published" ? "status-published" : "status-draft");
    }

    function syncEditorButtons() {
  const role = currentProfile?.role || "viewer";
  const isAdmin = role === "admin";
  const isEditor = role === "editor";

  if (!currentWeek) {
    btnSaveWeek.disabled = true;
    btnPublishWeek.disabled = true;
    btnPublishWeek.textContent = "Publish";
    return;
  }

  const isDraft = currentWeek.status === "draft";

  // Viewers & public: no controls
  if (isPublicViewer || role === "viewer") {
    btnSaveWeek.disabled = true;
    btnPublishWeek.disabled = true;
    btnPublishWeek.textContent = isDraft ? "Publish" : "Re-publish";
    return;
  }

  if (isDraft) {
    // Draft weeks: only Admin can touch
    btnSaveWeek.disabled = !isAdmin;
    btnPublishWeek.disabled = !isAdmin;
    btnPublishWeek.textContent = "Publish";
    } else {
    // Published weeks:
    // - Admin & Editor can edit and re-publish
    btnSaveWeek.disabled = !(isAdmin || isEditor);
    btnPublishWeek.disabled = !(isAdmin || isEditor);
    btnPublishWeek.textContent = "Re-publish";
  }
}

    // ===== CLASSIFY SHIFTS =====
    function classifyShift(value, tags) {
  const classes = [];
  const v = (value || "").trim().toUpperCase();
  const tagSet = new Set((tags || []).map((t) => String(t).toUpperCase()));

  if (!v && tagSet.size === 0) return "";

  // Base on times / text
  if (v.includes("0600-1800") || v.includes("0700-1900") || v.includes("0630-1830")) {
    classes.push("shift-day");
  }
  if (v.includes("1800-0600") || v.includes("1830-0630")) {
    classes.push("shift-night");
  }
  if (v.includes("SPARE")) {
    classes.push("shift-spare");
  }
  if (v === "N/A") {
    classes.push("shift-oo");
  }
  if (v === "RD") {
    classes.push("shift-rd");
  }

  // Based on tags OR legacy text markers
  const hasAL   = tagSet.has("AL")   || v.includes("A/L");
  const hasCL   = tagSet.has("CL")   || v.includes("C/L");
  const hasSick = tagSet.has("SICK") || v.includes("SICK") || v.includes("S/L");
  const hasBO   = tagSet.has("BO")   || v.includes("B.O");
  const hasRop  = tagSet.has("LROP") || tagSet.has("HROP") || v.includes("LROP") || v.includes("HROP");

  // 🔹 Only show grey 12+OC styling if it's NOT on AL / CL / SICK / BO
  if (!hasAL && !hasCL && !hasSick && !hasBO && v.includes("12+OC")) {
    classes.push("shift-12oc");
  }

  if (hasAL)   classes.push("shift-al");
  if (hasCL)   classes.push("shift-cl");
  if (hasSick) classes.push("shift-sick");
  if (hasBO)   classes.push("shift-bo");
  if (hasRop)  classes.push("shift-rop");

  return classes.join(" ");
}

    const BLOCKED_MODIFIERS = ["RDW", "A/L", "C/L", "LROP", "HROP", "B.O", "SICK", "HGD"];

    function enforceShiftInputRules(input) {
      let original = input.value || "";
      let working = original;

      BLOCKED_MODIFIERS.forEach((tok) => {
        const pattern = tok.replace(".", "\\.");
        const re = new RegExp(pattern, "ig");
        working = working.replace(re, "");
      });

      // Normalise spaces
      working = working.replace(/\s{2,}/g, " ").trim();

      if (working !== original) {
        alert("Shift modifiers cannot be typed into this cell, use the tags to complete this function");
        input.value = working;
      }
    }

    // Ensure uncovered structure supports two slots (s1, s2)
    function ensureUncovered(section) {
      if (!section.uncovered) {
        section.uncovered = {};
      }

      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      days.forEach((day) => {
        const current = section.uncovered[day];

        if (typeof current === "string") {
          section.uncovered[day] = {
            s1: current,
            s2: ""
          };
        } else if (!current || typeof current !== "object") {
          section.uncovered[day] = {
            s1: "",
            s2: ""
          };
        } else {
          section.uncovered[day].s1 = section.uncovered[day].s1 || "";
          section.uncovered[day].s2 = section.uncovered[day].s2 || "";
        }
      });
    }

    // Returns true if the current week-ending date includes today's date
    function weekContainsToday(weekEndingStr) {
      if (!weekEndingStr) return false;
      const end = new Date(weekEndingStr);
      if (isNaN(end)) return false;

      const today = new Date();
      const oneDay = 24 * 60 * 60 * 1000;

      const diffDays = Math.floor((end - today) / oneDay);

      return diffDays >= 0 && diffDays <= 6;
    }

    // Prompt user if they try to leave with unsaved changes
    function confirmDiscardChanges() {
      if (!hasUnsavedChanges) return true;
      return window.confirm("Are you sure you want to leave this roster without saving?");
    }

    // Browser-level guard (tab close / reload / URL change)
    window.addEventListener("beforeunload", (e) => {
      if (!hasUnsavedChanges) return;
      e.preventDefault();
      e.returnValue = "";
    });

    // Apply a tag from the tray to a single cell
    function applyTagToCell(sectionId, rowIndex, dayKey) {
      if (!currentWeek || !activeTag) return;
      if (isEffectiveReadOnly()) return;

      const sections = currentWeek.data.sections || [];
      const section = sections.find((s) => s.id === sectionId);
      if (!section) return;
      if (!section.rows || !section.rows[rowIndex]) return;

      const row = section.rows[rowIndex];
      ensureRowTags(row);

      const tags = row.tags[dayKey] || [];
      const tagUpper = activeTag.toUpperCase();

      // CLEAR mode: remove all tags from this cell + reset RDW flag
      if (tagUpper === "CLEAR") {
        row.tags[dayKey] = [];
        if (row.rdw && Object.prototype.hasOwnProperty.call(row.rdw, dayKey)) {
          row.rdw[dayKey] = false;
        }
      } else {
        const existingIndex = tags.findIndex((t) => String(t).toUpperCase() === tagUpper);
        if (existingIndex >= 0) {
          // Remove tag
          tags.splice(existingIndex, 1);
          row.tags[dayKey] = tags;
          if (tagUpper === "RDW") {
            if (!row.rdw) row.rdw = {};
            row.rdw[dayKey] = false;
          }
        } else {
                   // Add tag
          tags.push(tagUpper);
          row.tags[dayKey] = tags;
          if (tagUpper === "RDW") {
            if (!row.rdw) row.rdw = {};
            row.rdw[dayKey] = true;
          }

          // If A/L or C/L is being added, mirror the existing shift into the uncovered row (unless it's SPARE)
          if (
  tagUpper === "AL" ||
  tagUpper === "CL" ||
  tagUpper === "BO" ||
  tagUpper === "SICK"
) {
            // Make sure the uncovered structure exists for this section/day
            ensureUncovered(section);
            const u = section.uncovered[dayKey];
            const shiftVal =
              row.shifts && row.shifts[dayKey]
                ? String(row.shifts[dayKey])
                : "";
            const upperShift = shiftVal.toUpperCase();

            // Ignore pure spare shifts
            if (shiftVal && !upperShift.includes("SPARE")) {
              if (!u.s1) {
                u.s1 = shiftVal;
              } else if (!u.s2) {
                u.s2 = shiftVal;
              }
            }
          }
        }
      }

 // Mark roster as dirty
      hasUnsavedChanges = true;

      renderRosterGrid(currentWeek.data);
      updateCoverageBanner();
    }

    // ===== ROSTER RENDERING =====
    function renderRosterGrid(data) {
      rosterGrid.innerHTML = "";

      if (!data || !Array.isArray(data.sections)) {
        rosterGrid.innerHTML = "<p class='muted'>No sections defined in this roster.</p>";
        return;
      }

      const effectiveReadOnly = isEffectiveReadOnly();

      data.sections.forEach((section) => {
        ensureUncovered(section);

        const sectionDiv = document.createElement("div");
        sectionDiv.classList.add("mt-3");

        const headerDiv = document.createElement("div");
        headerDiv.classList.add("flex-between", "mb-1");
        headerDiv.innerHTML = `
          <div class="flex">
            <h3 style="margin:0;font-size:0.95rem;color:#0f172a;">${section.title || "Section"}</h3>
            ${section.note ? `<span class="tag">${section.note}</span>` : ""}
          </div>
        `;
        sectionDiv.appendChild(headerDiv);

        const table = document.createElement("table");
        table.classList.add("roster-table");
        const thead = document.createElement("thead");

        // Header row 1: dates
        const dateRow = document.createElement("tr");
        const thBlank = document.createElement("th");
        dateRow.appendChild(thBlank);
        ["sun", "mon", "tue", "wed", "thu", "fri", "sat"].forEach((dayKey) => {
          const th = document.createElement("th");
          const d = currentWeek ? getDateForDay(currentWeek.week_ending, dayKey) : null;
          th.textContent = d ? String(d.getDate()).padStart(2, "0") : "";
          dateRow.appendChild(th);
        });
        const thBlankEnd = document.createElement("th");
        dateRow.appendChild(thBlankEnd);
        thead.appendChild(dateRow);

        // Header row 2: day labels
        const headerRow = document.createElement("tr");
        headerRow.innerHTML = `
          <th>Name</th>
          <th>Sun</th>
          <th>Mon</th>
          <th>Tue</th>
          <th>Wed</th>
          <th>Thu</th>
          <th>Fri</th>
          <th>Sat</th>
          <th>Remarks</th>
        `;
        thead.appendChild(headerRow);

        table.appendChild(thead);

        const tbody = document.createElement("tbody");

        // Uncovered row
        const uncoveredTr = document.createElement("tr");
        const uncoveredNameTd = document.createElement("td");
        uncoveredNameTd.textContent = "Uncovered shifts";
        uncoveredNameTd.style.fontWeight = "600";
        uncoveredNameTd.style.background = "#e5e7eb";
        uncoveredNameTd.style.textAlign = "left";
        uncoveredTr.appendChild(uncoveredNameTd);

        const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
        days.forEach((day) => {
          const td = document.createElement("td");
          const dayObj = (section.uncovered && section.uncovered[day]) || { s1: "", s2: "" };

          ["s1", "s2"].forEach((slot) => {
            const input = document.createElement("input");
            input.value = dayObj[slot] || "";
            input.dataset.sectionId = section.id;
            input.dataset.day = day;
            input.dataset.slot = slot;
            input.className = "shift-input " + classifyShift(input.value, []);
            input.style.display = "block";
            input.style.marginBottom = "2px";

            if (effectiveReadOnly) {
              input.disabled = true;
            } else {
              input.addEventListener("input", handleUncoveredChange);
            }

            td.appendChild(input);
          });

          uncoveredTr.appendChild(td);
        });

        const uncoveredRemarksTd = document.createElement("td");
        uncoveredRemarksTd.textContent = "";
        uncoveredTr.appendChild(uncoveredRemarksTd);

        tbody.appendChild(uncoveredTr);

        // Staff rows
        (section.rows || []).forEach((row, rowIndex) => {
          ensureRowTags(row);

          const tr = document.createElement("tr");

          function makeCell(key) {
            const td = document.createElement("td");

            if (row.spare_origin && row.spare_origin[key]) {
              td.classList.add("spare-origin-cell");
            }

            const wrap = document.createElement("div");
            wrap.className = "shift-cell-wrap";

            const shiftValue = row.shifts?.[key] || "";

            // Build tag list for this cell
            let tags = Array.isArray(row.tags?.[key]) ? [...row.tags[key]] : [];
            // Backward compat: if RDW flag set but tag missing, inject it for display
            if (row.rdw && row.rdw[key]) {
              const hasRdwTag = tags.some((t) => String(t).toUpperCase() === "RDW");
              if (!hasRdwTag) tags.push("RDW");
            }

            const input = document.createElement("input");
            input.value = shiftValue;
            input.dataset.sectionId = section.id;
            input.dataset.rowIndex = rowIndex;
            input.dataset.field = key;
            input.className = "shift-input " + classifyShift(shiftValue, tags);
            input.setAttribute("list", "shift-presets");

            if (effectiveReadOnly) {
              input.disabled = true;
            } else {
              input.addEventListener("input", handleShiftChange);
            }

            wrap.appendChild(input);

            // Tag pills under shift
            const tagRow = document.createElement("div");
            tagRow.className = "tag-row";

            tags.forEach((tag) => {
              const tUpper = String(tag).toUpperCase();
              const pill = document.createElement("span");
              pill.classList.add("tag-pill");

              if (tUpper === "RDW") pill.classList.add("tag-pill-rdw");
              else if (tUpper === "AL") pill.classList.add("tag-pill-al");
              else if (tUpper === "CL") pill.classList.add("tag-pill-cl");
              else if (tUpper === "SICK") pill.classList.add("tag-pill-sick");
              else if (tUpper === "BO") pill.classList.add("tag-pill-bo");
              else if (tUpper === "LROP" || tUpper === "HROP") pill.classList.add("tag-pill-rop");
              else if (tUpper === "HGD") pill.classList.add("tag-pill-hgd");

              pill.textContent = tUpper;
              tagRow.appendChild(pill);
            });

            wrap.appendChild(tagRow);
            td.appendChild(wrap);

            // Apply tag from tray on cell click (but not when clicking the input or pills directly)
            if (!effectiveReadOnly) {
              td.addEventListener("click", (e) => {
                const targetTag = e.target;
                if (targetTag.tagName && targetTag.tagName.toLowerCase() === "input") return;
                if (targetTag.classList && targetTag.classList.contains("tag-pill")) return;
                if (!activeTag) return;
                applyTagToCell(section.id, rowIndex, key);
              });
            }

            return td;
          }

          const nameTd = document.createElement("td");
          const nameInput = document.createElement("input");
          nameInput.value = row.staff_name || "";
          nameInput.dataset.sectionId = section.id;
          nameInput.dataset.rowIndex = rowIndex;
          nameInput.dataset.field = "staff_name";

          if (effectiveReadOnly) {
            nameInput.disabled = true;
          } else {
            nameInput.addEventListener("input", handleNameChange);
          }

          nameTd.appendChild(nameInput);
          tr.appendChild(nameTd);

          ["sun", "mon", "tue", "wed", "thu", "fri", "sat"].forEach((day) => {
            tr.appendChild(makeCell(day));
          });

          const remarksTd = document.createElement("td");
          const remarksInput = document.createElement("textarea");
          remarksInput.value = row.remarks || "";
          remarksInput.dataset.sectionId = section.id;
          remarksInput.dataset.rowIndex = rowIndex;
          remarksInput.dataset.field = "remarks";
          remarksInput.className = "remark-input";
          remarksInput.rows = 1;

          if (effectiveReadOnly) {
            remarksInput.disabled = true;
          } else {
            const autoResize = () => {
              remarksInput.style.height = "auto";
              remarksInput.style.height = remarksInput.scrollHeight + "px";
            };
            remarksInput.addEventListener("input", (e) => {
              autoResize();
              handleRemarksChange(e);
            });
            autoResize();
          }

          remarksTd.appendChild(remarksInput);
          tr.appendChild(remarksTd);

          tbody.appendChild(tr);
        });

        table.appendChild(tbody);

        // Highlight current day column if this roster week contains today's date
        if (currentWeek && weekContainsToday(currentWeek.week_ending)) {
          const today = new Date();
          const jsDay = today.getDay();
          const dayIndex = jsDay;

          const headerRows = thead.querySelectorAll("tr");
          if (headerRows.length >= 2) {
            const dayHeaderCells = headerRows[1].querySelectorAll("th");
            if (dayHeaderCells[dayIndex + 1]) {
              dayHeaderCells[dayIndex + 1].classList.add("today-col");
            }
          }

          const bodyRows = tbody.querySelectorAll("tr");
          bodyRows.forEach((rowEl) => {
            const cells = rowEl.querySelectorAll("td");
            if (cells[dayIndex + 1]) {
              cells[dayIndex + 1].classList.add("today-col");
            }
          });
        }

        sectionDiv.appendChild(table);
        rosterGrid.appendChild(sectionDiv);
      });

      applyRosterFilter();
    }

    // ===== CHANGE HANDLERS =====
    function handleUncoveredChange(e) {
      if (isEffectiveReadOnly()) return;

      const input = e.target;
      enforceShiftInputRules(input);
      const sectionId = input.dataset.sectionId;
      const day = input.dataset.day;
      const slot = input.dataset.slot || "s1";

      const sections = currentWeek.data.sections || [];
      const section = sections.find((s) => s.id === sectionId);
      if (!section) return;

      ensureUncovered(section);
      const dayObj = section.uncovered[day];
      if (!dayObj) return;

            dayObj[slot] = input.value;
      input.className = "shift-input " + classifyShift(input.value, []);

      hasUnsavedChanges = true;
      updateCoverageBanner();
    }

    function handleNameChange(e) {
      if (isEffectiveReadOnly()) return;

      const input = e.target;
      const sectionId = input.dataset.sectionId;
      const rowIndex = parseInt(input.dataset.rowIndex, 10);

      const sections = currentWeek.data.sections || [];
      const section = sections.find((s) => s.id === sectionId);
      if (!section) return;

            if (!section.rows[rowIndex]) section.rows[rowIndex] = {};
      section.rows[rowIndex].staff_name = input.value;
      hasUnsavedChanges = true;
    }

    function handleRemarksChange(e) {
      if (isEffectiveReadOnly()) return;

      const input = e.target;
      const sectionId = input.dataset.sectionId;
      const rowIndex = parseInt(input.dataset.rowIndex, 10);

      const sections = currentWeek.data.sections || [];
      const section = sections.find((s) => s.id === sectionId);
      if (!section) return;

            if (!section.rows[rowIndex]) section.rows[rowIndex] = {};
      section.rows[rowIndex].remarks = input.value;
      hasUnsavedChanges = true;
    }

    function handleShiftChange(e) {
      if (isEffectiveReadOnly()) return;

      const input = e.target;
      enforceShiftInputRules(input);
      const sectionId = input.dataset.sectionId;
      const rowIndex = parseInt(input.dataset.rowIndex, 10);
      const field = input.dataset.field;

      const sections = currentWeek.data.sections || [];
      const section = sections.find((s) => s.id === sectionId);
      if (!section) return;

      if (!section.rows[rowIndex]) section.rows[rowIndex] = { shifts: {} };
      if (!section.rows[rowIndex].shifts) section.rows[rowIndex].shifts = {};
      if (!section.rows[rowIndex].tags) section.rows[rowIndex].tags = {};

      section.rows[rowIndex].shifts[field] = input.value;

            const tags = section.rows[rowIndex].tags[field] || [];
      input.className = "shift-input " + classifyShift(input.value, tags);

      hasUnsavedChanges = true;
      updateCoverageBanner();
    }

    // ===== SAVE / PUBLISH / PRINT =====
    btnSaveWeek.addEventListener("click", async () => {
      const role = currentProfile?.role || "viewer";
      if (!currentWeek || isPublicViewer || role === "viewer") return;

      const { data, error } = await supabase
        .from("roster_weeks")
        .update({ data: currentWeek.data })
        .eq("id", currentWeek.id)
        .select("*")
        .single();

           if (error) {
        console.error(error);
        alert("Error saving week.");
        return;
      }
      currentWeek = data;
      hasUnsavedChanges = false;
      alert("Draft saved.");
    });

async function saveVersionSnapshotForCurrentWeek() {
  if (!currentWeek || !currentWeek.id || !currentWeek.data) return;

  try {
    const { data: existing, error: loadErr } = await supabase
      .from("roster_week_revisions")
      .select("id")
      .eq("week_id", currentWeek.id);

    if (loadErr) {
      console.warn("saveVersionSnapshot load error", loadErr);
    }

    const nextVersion = (existing ? existing.length : 0) + 1;

    let snapshot;
    try {
      snapshot = JSON.parse(JSON.stringify(currentWeek.data));
    } catch (e) {
      console.warn("saveVersionSnapshot clone error", e);
      return;
    }

    const { error: insertErr } = await supabase
      .from("roster_week_revisions")
      .insert({
        week_id: currentWeek.id,
        snapshot,
        label: `V${nextVersion}`,
        created_by: currentUser?.id || null
      });

    if (insertErr) {
      console.warn("saveVersionSnapshot insert error", insertErr);
    }
  } catch (e) {
    console.warn("saveVersionSnapshot exception", e);
  }
}

   btnPublishWeek.addEventListener("click", async () => {
  const role = currentProfile?.role || "viewer";
  const canPublish =
    !isPublicViewer && (role === "admin" || role === "editor");

  if (!currentWeek || !canPublish) return;

  const payload = {
    status: "published",
    published_at: new Date().toISOString(),
    data: currentWeek.data,
    last_published_data: currentWeek.data
  };

  const { data, error } = await supabase
    .from("roster_weeks")
    .update(payload)
    .eq("id", currentWeek.id)
    .select("*")
    .single();

  if (error) {
    console.error(error);
    alert("Error publishing week.");
    return;
  }

  currentWeek = data;
  setStatusPill("published");
  syncEditorButtons();

  // 🔹 Save a versioned snapshot: V1, V2, V3...
  await saveVersionSnapshotForCurrentWeek();

  hasUnsavedChanges = false;

  await loadWeeks();
  await loadAnalyticsYears();
  await refreshAnalytics();
  await refreshExpiryWatch();
  await refreshShiftMarket();

  alert("Week published.");
});


    btnPrintWeek.addEventListener("click", () => {
      if (!currentWeek) {
        alert("Open a week before printing.");
        return;
      }
      window.print();
    });

    // ===== ANALYTICS =====
    async function loadAnalyticsYears() {
            const { data, error } = await supabase
        .from("roster_weeks")
        .select("week_ending")
        .eq("link", currentLink)
        .order("week_ending", { ascending: false });

      if (error) {
        console.error("loadAnalyticsYears error", error);
        return;
      }

      const yearsSet = new Set();
      data.forEach((w) => {
        if (!w.week_ending) return;
        const d = new Date(w.week_ending);
        if (!isNaN(d)) {
          yearsSet.add(d.getFullYear());
        }
      });

      const years = Array.from(yearsSet).sort((a, b) => b - a);
      analyticsYearSelect.innerHTML = "";

      if (!years.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No data";
        analyticsYearSelect.appendChild(opt);
        return;
      }

      years.forEach((y) => {
        const opt = document.createElement("option");
        opt.value = String(y);
        opt.textContent = y;
        analyticsYearSelect.appendChild(opt);
      });

      const currentYear = new Date().getFullYear();
      if (years.includes(currentYear)) {
        analyticsYearSelect.value = String(currentYear);
      } else {
        analyticsYearSelect.value = String(years[0]);
      }
    }

    btnRefreshAnalytics.addEventListener("click", () => {
      refreshAnalytics();
      refreshExpiryWatch();
    });

    btnToggleAnalytics.addEventListener("click", () => {
      const collapsed = analyticsBody.classList.toggle("hidden");
      btnToggleAnalytics.textContent = collapsed ? "Show" : "Hide";
    });

// Change log button listener
if (btnChangeLog) {
  btnChangeLog.addEventListener("click", () => {
    showChangeLog();
  });
}

    async function loadLeaveAllowances(year) {
      leaveAllowancesByName = {};
      currentAnalyticsYear = year;

            const { data, error } = await supabase
        .from("leave_allowances")
        .select("id, staff_name, year, al_allowance, cl_base_allowance")
        .eq("year", year)
        .eq("link", currentLink);

      if (error) {
        console.error("loadLeaveAllowances error", error);
        return;
      }

      (data || []).forEach((row) => {
        const name = (row.staff_name || "").trim();
        if (!name) return;
        leaveAllowancesByName[name] = {
          id: row.id,
          al: row.al_allowance || 0
        };
      });
    }

    // Year-scoped analytics: counts per person & weekly stats
    function computeYearAnalyticsFromWeeks(weeks) {
      const weeklyStats = [];
      const usageMap = {};
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      weeks.forEach((w) => {
        let weekAL = 0;
        let weekCL = 0;
        let weekSick = 0;
        let weekRDWTotal = 0;
        let weekRDWSun = 0;
        let weekUncovered = 0;

        const struct = w.data;
        if (!struct || !Array.isArray(struct.sections)) return;

        struct.sections.forEach((section) => {
          ensureUncovered(section);

          days.forEach((day) => {
            const u = section.uncovered?.[day];
            if (typeof u === "string") {
              if (u.trim()) weekUncovered += 1;
            } else if (u && typeof u === "object") {
              if ((u.s1 || "").trim()) weekUncovered += 1;
              if ((u.s2 || "").trim()) weekUncovered += 1;
            }
          });

          (section.rows || []).forEach((row) => {
            const staffName = (row.staff_name || "").trim();
            if (staffName && !usageMap[staffName]) {
              usageMap[staffName] = {
                name: staffName,
                al: 0,
                cl: 0,
                rdwTotal: 0,
                rdwSun: 0
              };
            }

            days.forEach((day) => {
              const shift = row.shifts?.[day];
              const v = (shift || "").toUpperCase();
              const tags = Array.isArray(row.tags?.[day]) ? row.tags[day] : [];
              const tagSet = new Set(tags.map((t) => String(t).toUpperCase()));

              if (!v && tagSet.size === 0) return;

              const hasAL = tagSet.has("AL") || v.includes("A/L");
              const hasCL = tagSet.has("CL") || v.includes("C/L");
              const hasSick = tagSet.has("SICK") || v.includes("SICK") || v.includes("S/L");

              if (hasAL) {
                weekAL++;
                if (staffName) usageMap[staffName].al++;
              }
              if (hasCL) {
                weekCL++;
                if (staffName) usageMap[staffName].cl++;
              }
              if (hasSick) {
                weekSick++;
              }

              const isRDW = row.rdw && row.rdw[day];
              if (isRDW) {
                weekRDWTotal++;
                if (day === "sun") weekRDWSun++;
                if (staffName) {
                  usageMap[staffName].rdwTotal++;
                  if (day === "sun") usageMap[staffName].rdwSun++;
                }
              }
            });
          });
        });

        weeklyStats.push({
          weekEnding: w.week_ending,
          label: w.label || "",
          al: weekAL,
          cl: weekCL,
          sick: weekSick,
          rdwTotal: weekRDWTotal,
          rdwSun: weekRDWSun,
          uncovered: weekUncovered
        });
      });

      const usageStats = Object.values(usageMap).filter((u) => u.name);
      usageStats.sort((a, b) => a.name.localeCompare(b.name));

      return { weeklyStats, usageStats };
    }

    // Per-person leave detail for selected year
    function computeLeaveDetailForYear(weeks, year) {
      const map = {};
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      weeks.forEach((w) => {
        const struct = w.data;
        if (!struct || !Array.isArray(struct.sections)) return;

        struct.sections.forEach((section) => {
          (section.rows || []).forEach((row) => {
            const staffName = (row.staff_name || "").trim();
            if (!staffName) return;

            if (!map[staffName]) {
              map[staffName] = {
                alDates: [],
                clDates: []
              };
            }

            days.forEach((day) => {
              const shift = row.shifts?.[day];
              const v = (shift || "").toUpperCase();
              const tags = Array.isArray(row.tags?.[day]) ? row.tags[day] : [];
              const tagSet = new Set(tags.map((t) => String(t).toUpperCase()));

              if (!v && tagSet.size === 0) return;

              const d = getDateForDay(w.week_ending, day);
              if (!d || d.getFullYear() !== year) return;

              const hasAL = tagSet.has("AL") || v.includes("A/L");
              const hasCL = tagSet.has("CL") || v.includes("C/L");

              if (hasAL) {
                map[staffName].alDates.push(d);
              }
              if (hasCL) {
                map[staffName].clDates.push(d);
              }
            });
          });
        });
      });

      return map;
    }

    // Full-history LROP/C/L credit bank
    function computeCompBankFromWeeks(weeks, today) {
      const map = {};
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      weeks.forEach((w) => {
        const struct = w.data;
        if (!struct || !Array.isArray(struct.sections)) return;

        struct.sections.forEach((section) => {
          (section.rows || []).forEach((row) => {
            const staffName = (row.staff_name || "").trim();
            if (!staffName) return;

            if (!map[staffName]) {
              map[staffName] = {
                lropDates: [],
                clUsedDates: [],
                usable: 0,
                usedLast365: 0,
                validCreditDates: []
              };
            }

            days.forEach((day) => {
              const shift = row.shifts?.[day];
              const v = (shift || "").toUpperCase();
              const tags = Array.isArray(row.tags?.[day]) ? row.tags[day] : [];
              const tagSet = new Set(tags.map((t) => String(t).toUpperCase()));
              if (!v && tagSet.size === 0) return;

              const d = getDateForDay(w.week_ending, day);
              if (!d) return;

              const hasCL = tagSet.has("CL") || v.includes("C/L");
              const hasLROP = tagSet.has("LROP") || v.includes("LROP");

              if (hasLROP) {
                map[staffName].lropDates.push(d);
              }
              if (hasCL) {
                map[staffName].clUsedDates.push(d);
              }
            });
          });
        });
      });

      const cutoff = addDays(today, -365);

      Object.entries(map).forEach(([name, rec]) => {
        const credits = rec.lropDates
          .map((d) => {
            const expiry = new Date(d.getTime());
            expiry.setFullYear(expiry.getFullYear() + 1);
            return { date: d, expiry, consumed: false };
          })
          .sort((a, b) => a.date - b.date);

        let usesLeft = rec.clUsedDates.length;

        for (let i = 0; i < credits.length && usesLeft > 0; i++) {
          if (!credits[i].consumed) {
            credits[i].consumed = true;
            usesLeft--;
          }
        }

        const usableCredits = credits.filter(
          (c) => !c.consumed && c.expiry >= today
        );
        rec.usable = usableCredits.length < 0 ? 0 : usableCredits.length;
        rec.validCreditDates = usableCredits.map((c) => c.date);

        rec.usedLast365 = rec.clUsedDates.filter(
          (d) => d >= cutoff && d <= today
        ).length;
      });

      return map;
    }

    async function refreshAnalytics() {
      const yearStr = analyticsYearSelect.value;
      if (!yearStr) {
        analyticsWeeklyTbody.innerHTML = "";
        analyticsUsageTbody.innerHTML = "";
        analyticsLeaveTbody.innerHTML = "";
        return;
      }
      const year = Number(yearStr);

      await loadLeaveAllowances(year);

      // 1) Year-scoped stats
      const start = `${year}-01-01`;
      const end = `${year}-12-31`;

            const { data: yearWeeks, error: yearErr } = await supabase
        .from("roster_weeks")
        .select("id, week_ending, label, data")
        .eq("link", currentLink)
        .gte("week_ending", start)
        .lte("week_ending", end)
        .order("week_ending", { ascending: true });

      if (yearErr) {
        console.error("refreshAnalytics (year) error", yearErr);
        return;
      }

      const { weeklyStats, usageStats } =
        computeYearAnalyticsFromWeeks(yearWeeks || []);

      const leaveDetailYear = computeLeaveDetailForYear(yearWeeks || [], year);

      // 2) Full-history comp bank
      const today = new Date();
            const { data: allWeeks, error: allErr } = await supabase
        .from("roster_weeks")
        .select("id, week_ending, data")
        .eq("link", currentLink)
        .order("week_ending", { ascending: true });

      if (allErr) {
        console.error("refreshAnalytics (all weeks) error", allErr);
        return;
      }

      const compBank = computeCompBankFromWeeks(allWeeks || [], today);

      renderWeeklyAnalytics(weeklyStats);
      lastUsageStats = usageStats;
      applyUsageFilter();
      renderLeaveAnalytics(usageStats, compBank, leaveDetailYear);
    }

    // ===== SHIFT MARKET (uncovered shifts with interest) =====
    let shiftMarketStaffNames = [];

    function buildUsageMap() {
      const map = {};
      (lastUsageStats || []).forEach((u) => {
        map[u.name] = {
          rdwTotal: u.rdwTotal || 0,
          rdwSun: u.rdwSun || 0
        };
      });
      return map;
    }

    function dayKeyToIndex(dayKey) {
      const order = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
      return order.indexOf(dayKey);
    }

function computeShiftMarketStatus(entry, interested, today) {
  const oneDay = 24 * 60 * 60 * 1000;
  const shiftDate = entry.dateObj;
  if (!shiftDate) {
    return { emoji: "⚪", label: "No date available" };
  }

  const daysUntil = Math.floor((shiftDate - today) / oneDay);

  // No interest yet
  if (!interested || interested.length === 0) {
    // More than 4 weeks away: RED – no bids yet, plenty of time
    if (daysUntil > 28) {
      return {
        emoji: "🔴",
        label: "No interest yet."
      };
    }

    // Within 4 weeks and still nothing: BLACK – RCM needs to intervene
    return {
      emoji: "⚫",
      label: "RCM required to attempt to organise cover."
    };
  }

  // At least one interest: find earliest interest as bidding start
  let firstInterest = null;
  interested.forEach((r) => {
    if (!r.created_at) return;
    const d = new Date(r.created_at);
    if (!isNaN(d)) {
      if (!firstInterest || d < firstInterest) firstInterest = d;
    }
  });

  if (!firstInterest) {
    // Failsafe: treat as bidding but no usable created_at
    return {
      emoji: "🟡",
      label: "Bidding window open."
    };
  }

  const biddingEnd = new Date(firstInterest.getTime() + 14 * oneDay);
  const daysLeft = Math.max(
    0,
    Math.ceil((biddingEnd - today) / oneDay)
  );

  // YELLOW: bidding window open (first interest, < 2 weeks since, and > 4 weeks away)
  if (today < biddingEnd && daysUntil > 28) {
    return {
      emoji: "🟡",
      label: `Bidding window open – ${daysLeft} day(s) remaining.`
    };
  }

  // GREEN: either 2+ weeks have passed since first interest OR we are within 4 weeks
  // and there is at least one bid. Someone has effectively "won".
  return {
    emoji: "🟢",
    label: "Interest registered – allocate from ranked list."
  };
}

    async function refreshShiftMarket() {
      if (!shiftMarketTbody) return;

      shiftMarketTbody.innerHTML = "";
      shiftMarketStaffNames = [];

      // Only show for roster_weeks that are published and from "today" onwards.
      const today = new Date();
      const todayStr = today.toISOString().slice(0, 10);

      let weeksData = [];
      try {
                const { data, error } = await supabase
          .from("roster_weeks")
          .select("id, week_ending, label, status, data")
          .eq("status", "published")
          .eq("link", currentLink)
          .gte("week_ending", todayStr)
          .order("week_ending", { ascending: true });

        if (error) {
          console.warn("refreshShiftMarket roster_weeks error", error);
          return;
        }
        weeksData = data || [];
      } catch (e) {
        console.warn("refreshShiftMarket roster_weeks exception", e);
        return;
      }

      const entries = [];
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      weeksData.forEach((w) => {
        if (!w.data || !Array.isArray(w.data.sections)) return;
        w.data.sections.forEach((section) => {
          ensureUncovered(section);
          // collect names for dropdown
          (section.rows || []).forEach((row) => {
            const name = (row.staff_name || "").trim();
            if (name && !shiftMarketStaffNames.includes(name)) {
              shiftMarketStaffNames.push(name);
            }
          });

          days.forEach((dayKey) => {
            const u = section.uncovered?.[dayKey];
            if (!u) return;

            const slots = typeof u === "string"
              ? { s1: u, s2: "" }
              : { s1: u.s1 || "", s2: u.s2 || "" };

            ["s1", "s2"].forEach((slot) => {
              const val = (slots[slot] || "").trim();
              if (!val) return;

              const dateObj = getDateForDay(w.week_ending, dayKey);
              entries.push({
                weekId: w.id,
                weekEnding: w.week_ending,
                sectionId: section.id || null,
                sectionTitle: section.title || "Section",
                dayKey,
                slot,
                shiftText: val,
                dateObj
              });
            });
          });
        });
      });

      shiftMarketStaffNames.sort((a, b) => a.localeCompare(b));

      // Load existing interest registrations (if table exists)
      let interestRows = [];
      try {
                const { data: interestData, error: interestErr } = await supabase
          .from("shift_market_interest")
          .select("id, week_id, section_id, day_key, slot, staff_name, created_at, link")
          .eq("link", currentLink);

        if (interestErr) {
          console.warn("refreshShiftMarket interest error", interestErr);
        } else {
          interestRows = interestData || [];
        }
      } catch (e) {
        console.warn("refreshShiftMarket interest exception", e);
      }

      const interestByKey = {};
      interestRows.forEach((row) => {
        const key = `${row.week_id}|${row.section_id || ""}|${row.day_key}|${row.slot}`;
        if (!interestByKey[key]) interestByKey[key] = [];
        interestByKey[key].push(row);
      });

      const usageMap = buildUsageMap();

      if (!entries.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="5" class="muted">No uncovered published shifts from the current week onwards.</td>`;
        shiftMarketTbody.appendChild(tr);
        return;
      }

      entries.forEach((e) => {
  const key = `${e.weekId}|${e.sectionId || ""}|${e.dayKey}|${e.slot}`;
  const interested = (interestByKey[key] || []).slice();

  const isSunday = e.dayKey === "sun";
  interested.sort((a, b) => {
    const ua = usageMap[a.staff_name] || { rdwTotal: 0, rdwSun: 0 };
    const ub = usageMap[b.staff_name] || { rdwTotal: 0, rdwSun: 0 };
    const aScore = isSunday ? ua.rdwSun : ua.rdwTotal;
    const bScore = isSunday ? ub.rdwSun : ub.rdwTotal;
    if (aScore !== bScore) return aScore - bScore;
    return a.staff_name.localeCompare(b.staff_name);
  });

  const tr = document.createElement("tr");

  // NEW: status cell with emoji
  const statusTd = document.createElement("td");
  const status = computeShiftMarketStatus(e, interested, today);
  statusTd.textContent = status.emoji;
  statusTd.title = status.label;
  statusTd.style.textAlign = "center";
  tr.appendChild(statusTd);

  const weekTd = document.createElement("td");
  weekTd.textContent = formatUK(e.weekEnding);
  tr.appendChild(weekTd);

  const dateTd = document.createElement("td");
  dateTd.textContent = e.dateObj ? formatUK(e.dateObj.toISOString()) : "";
  tr.appendChild(dateTd);

  const sectionTd = document.createElement("td");
  sectionTd.textContent = e.sectionTitle;
  tr.appendChild(sectionTd);

  const shiftTd = document.createElement("td");
  shiftTd.textContent = e.shiftText;
  tr.appendChild(shiftTd);

  const interestTd = document.createElement("td");
  interestTd.style.textAlign = "left";

        // Everyone (including public viewer) can register interest
        const controlWrap = document.createElement("div");
        controlWrap.className = "flex";
        controlWrap.style.alignItems = "center";

        const select = document.createElement("select");
        select.className = "shift-market-name-select";
        select.dataset.shiftKey = key;

        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "Select name…";
        select.appendChild(defaultOpt);

        shiftMarketStaffNames.forEach((name) => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
        });

        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn btn-sm";
        btn.textContent = "Register";
        btn.dataset.shiftKey = key;

        btn.addEventListener("click", async () => {
          const chosenName = select.value;
          if (!chosenName) {
            alert("Pick a name to register interest.");
            return;
          }

          try {
                        const payload = {
              week_id: e.weekId,
              section_id: e.sectionId,
              day_key: e.dayKey,
              slot: e.slot,
              staff_name: chosenName,
              link: currentLink
            };
            const { error } = await supabase
              .from("shift_market_interest")
              .upsert(payload, {
                onConflict: "week_id,section_id,day_key,slot,staff_name,link"
              });
            if (error) {
              console.warn("Register interest error", error);
              alert("Unable to register interest (backend).");
              return;
            }
            await refreshShiftMarket();
          } catch (err) {
            console.warn("Register interest exception", err);
            alert("Unable to register interest.");
          }
        });

        controlWrap.appendChild(select);
        controlWrap.appendChild(btn);
        interestTd.appendChild(controlWrap);

       const rankDiv = document.createElement("div");
rankDiv.className = "muted";
rankDiv.style.fontSize = "0.75rem";
rankDiv.style.marginTop = "0.25rem";

if (interested.length) {
  rankDiv.textContent = "Ranked interest: ";

  interested.forEach((r, idx) => {
    const u = usageMap[r.staff_name] || { rdwTotal: 0, rdwSun: 0 };
    const score = isSunday ? u.rdwSun : u.rdwTotal;
    const label = isSunday ? `Sun RDW: ${score}` : `RDW: ${score}`;

    const pill = document.createElement("span");
    pill.textContent = `${r.staff_name} (${label})`;
    pill.style.cursor = "pointer";
    pill.style.textDecoration = "underline";
    pill.style.textDecorationStyle = "dotted";
    pill.style.marginRight = "0.35rem";

    pill.addEventListener("click", async () => {
      const sure = confirm(
        `Remove interest for ${r.staff_name} on this shift?`
      );
      if (!sure) return;

      try {
       const { error } = await supabase
  .from("shift_market_interest")
  .delete()
  .eq("id", r.id);

if (error) {
  console.warn("Remove interest error", error);
  alert("Unable to remove interest.");
  return;
}

        await refreshShiftMarket();
      } catch (err) {
        console.warn("Remove interest exception", err);
        alert("Unable to remove interest.");
      }
    });

    rankDiv.appendChild(pill);

    if (idx < interested.length - 1) {
      const sep = document.createElement("span");
      sep.textContent = " • ";
      rankDiv.appendChild(sep);
    }
  });
} else {
  rankDiv.textContent = "No interest registered yet.";
}
interestTd.appendChild(rankDiv);
        tr.appendChild(interestTd);
        shiftMarketTbody.appendChild(tr);
      });
    }

    function renderWeeklyAnalytics(rows) {
      analyticsWeeklyTbody.innerHTML = "";
      if (!rows.length) return;

      rows.forEach((r) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${formatUK(r.weekEnding)}</td>
          <td>${r.al}</td>
          <td>${r.cl}</td>
          <td>${r.sick}</td>
          <td>${r.rdwTotal}</td>
          <td>${r.rdwSun}</td>
          <td>${r.uncovered}</td>
        `;
        analyticsWeeklyTbody.appendChild(tr);
      });
    }

    function renderUsageAnalytics(rows) {
      analyticsUsageTbody.innerHTML = "";
      if (!rows.length) return;

      rows.forEach((r) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td style="text-align:left;">${r.name}</td>
          <td>${r.al}</td>
          <td>${r.cl}</td>
          <td>${r.rdwTotal}</td>
          <td>${r.rdwSun}</td>
        `;
        analyticsUsageTbody.appendChild(tr);
      });
    }

    function leaveRagClass(pct) {
      if (pct === null || pct === undefined) return "";
      if (pct > 90) return "leave-red";
      if (pct >= 70) return "leave-amber";
      return "leave-green";
    }

    // A/L (year) + C/L used (rolling 12m) + C/L usable (bank) + expandable details
    function renderLeaveAnalytics(usageRows, compBank, detailYearMap) {
      analyticsLeaveTbody.innerHTML = "";

      const usageByName = {};
      (usageRows || []).forEach((u) => {
        usageByName[u.name] = u;
      });

            const names = new Set([
        ...Object.keys(usageByName),
        ...Object.keys(compBank || {})
      ]);

      if (!names.size) return;

      const role = currentProfile?.role || "viewer";
      const canEditAllowances = !isPublicViewer && role === "admin";

      Array.from(names).sort().forEach((name) => {
        const usage = usageByName[name] || { al: 0, cl: 0 };
        const allowanceRow = leaveAllowancesByName[name] || { al: 0 };
        const comp = (compBank && compBank[name]) || {
          usable: 0,
          usedLast365: 0,
          validCreditDates: []
        };
        const detail = (detailYearMap && detailYearMap[name]) || {
          alDates: [],
          clDates: []
        };

        const alUsed = usage.al || 0;
        const alAllowance = allowanceRow.al || 0;
        const alPct = alAllowance > 0 ? Math.round((alUsed / alAllowance) * 100) : null;
        const alClass = leaveRagClass(alPct);

        const clUsedRolling = comp.usedLast365 || 0;
        const clUsableBalance = comp.usable || 0;

        const mainTr = document.createElement("tr");
        mainTr.className = "leave-main-row";
        mainTr.innerHTML = `
          <td style="text-align:left;">
            <button class="leave-toggle" type="button" aria-label="Toggle details">+</button>
            <span>${name}</span>
          </td>
          <td>${alUsed}</td>
          <td></td>
          <td></td>
          <td>${clUsedRolling}</td>
          <td></td>
        `;

        const tds = mainTr.querySelectorAll("td");

        const alInput = document.createElement("input");
        alInput.type = "number";
        alInput.min = "0";
        alInput.value = alAllowance;
        alInput.style.width = "4rem";
        alInput.dataset.type = "al-allowance";
        alInput.dataset.name = name;
        if (!canEditAllowances) alInput.disabled = true;
        tds[2].appendChild(alInput);

        if (alPct === null) {
          tds[3].innerHTML = `<span class="muted" style="font-size:0.7rem;">n/a</span>`;
        } else {
          const span = document.createElement("span");
          span.className = `leave-pill ${alClass}`;
          span.textContent = `${alPct}%`;
          tds[3].appendChild(span);
        }

        tds[5].textContent = clUsableBalance;

        const detailTr = document.createElement("tr");
        detailTr.className = "leave-detail-row hidden";
        const detailTd = document.createElement("td");
        detailTd.colSpan = 6;

        const block = document.createElement("div");
        block.className = "leave-detail-block";

        // A/L list
        const alHeader = document.createElement("h4");
        alHeader.textContent = "A/L used (selected year)";
        block.appendChild(alHeader);
        const alUl = document.createElement("ul");
        if (detail.alDates.length) {
          detail.alDates
            .sort((a, b) => a - b)
            .forEach((d) => {
              const li = document.createElement("li");
              li.textContent = formatUK(d.toISOString());
              alUl.appendChild(li);
            });
        } else {
          const li = document.createElement("li");
          li.textContent = "None recorded.";
          alUl.appendChild(li);
        }
        block.appendChild(alUl);

        // C/L used (year)
        const clHeader = document.createElement("h4");
        clHeader.textContent = "C/L used (selected year)";
        block.appendChild(clHeader);
        const clUl = document.createElement("ul");
        if (detail.clDates.length) {
          detail.clDates
            .sort((a, b) => a - b)
            .forEach((d) => {
              const li = document.createElement("li");
              li.textContent = formatUK(d.toISOString());
              clUl.appendChild(li);
            });
        } else {
          const li = document.createElement("li");
          li.textContent = "None recorded.";
          clUl.appendChild(li);
        }
        block.appendChild(clUl);

        // Valid credits
        const tokHeader = document.createElement("h4");
        tokHeader.textContent = "Current valid C/L credits (earn dates)";
        block.appendChild(tokHeader);
        const tokUl = document.createElement("ul");
        if (comp.validCreditDates && comp.validCreditDates.length) {
          comp.validCreditDates
            .sort((a, b) => a - b)
            .forEach((d) => {
              const li = document.createElement("li");
              li.textContent = formatUK(d.toISOString());
              tokUl.appendChild(li);
            });
        } else {
          const li = document.createElement("li");
          li.textContent = "No valid credits remaining.";
          tokUl.appendChild(li);
        }
        block.appendChild(tokUl);

        detailTd.appendChild(block);
        detailTr.appendChild(detailTd);

        analyticsLeaveTbody.appendChild(mainTr);
        analyticsLeaveTbody.appendChild(detailTr);
      });

      // Wire up expand/collapse
      analyticsLeaveTbody.querySelectorAll(".leave-toggle").forEach((btn) => {
        btn.addEventListener("click", () => {
          const row = btn.closest("tr");
          const detailRow = row.nextElementSibling;
          if (!detailRow || !detailRow.classList.contains("leave-detail-row")) return;
          const isHidden = detailRow.classList.toggle("hidden");
          btn.textContent = isHidden ? "+" : "−";
        });
      });
    }

    // Save A/L allowances
    btnSaveAllowances.addEventListener("click", async () => {
  const role = currentProfile?.role || "viewer";
  const isAdmin = !isPublicViewer && role === "admin";
  if (!isAdmin) {
    alert("You do not have permission to edit allowances.");
    return;
  }

  if (!currentAnalyticsYear) {
    alert("No analytics year selected.");
    return;
  }

      const rows = analyticsLeaveTbody.querySelectorAll("tr.leave-main-row");
      const payloads = [];

      rows.forEach((tr) => {
        const nameCell = tr.querySelector("td span");
        if (!nameCell) return;
        const name = nameCell.textContent.trim();
        if (!name) return;

        const alInput = tr.querySelector('input[data-type="al-allowance"]');
        const alAllowance = alInput ? Number(alInput.value || "0") : 0;

                payloads.push({
          staff_name: name,
          year: Number(currentAnalyticsYear),
          al_allowance: alAllowance,
          cl_base_allowance: 0,
          link: currentLink
        });
      });

      if (!payloads.length) return;

      leaveSaveStatus.textContent = "Saving…";

      const { error } = await supabase
        .from("leave_allowances")
               .upsert(payloads, { onConflict: "staff_name,year,link" });

      if (error) {
        console.error("save allowances error", error);
        leaveSaveStatus.textContent = "Error saving allowances.";
        return;
      }

      leaveSaveStatus.textContent = "Allowances saved.";
      await refreshAnalytics();
    });

    function applyUsageFilter() {
      const term = (usageFilterInput.value || "").trim().toLowerCase();
      if (!term) {
        renderUsageAnalytics(lastUsageStats);
      } else {
        const filtered = lastUsageStats.filter((u) =>
          u.name.toLowerCase().includes(term)
        );
        renderUsageAnalytics(filtered);
      }
    }

    usageFilterInput.addEventListener("input", applyUsageFilter);

    // ===== PER-WEEK ROSTER FILTER =====
    function applyRosterFilter() {
      if (!rosterFilterInput) return;
      const term = (rosterFilterInput.value || "").trim().toLowerCase();

      const tables = rosterGrid.querySelectorAll("table");
      tables.forEach((table) => {
        const rows = table.querySelectorAll("tbody tr");

        rows.forEach((tr, index) => {
          if (index === 0) {
            tr.style.display = "";
            return;
          }

          const nameInput = tr.querySelector("td:first-child input");
          if (!nameInput) return;

          const name = (nameInput.value || "").toLowerCase();

          if (!term || name.includes(term)) {
            tr.style.display = "";
          } else {
            tr.style.display = "none";
          }
        });
      });
    }

    if (rosterFilterInput) {
      rosterFilterInput.addEventListener("input", applyRosterFilter);
    }


    function normaliseCellTags(row, dayKey) {
      const tagsArr = Array.isArray(row.tags?.[dayKey]) ? row.tags[dayKey] : [];
      const set = new Set(tagsArr.map((t) => String(t).toUpperCase()));
      if (row.rdw && row.rdw[dayKey]) {
        set.add("RDW");
      }
      return Array.from(set).sort();
    }

    function describeShiftAndTags(shift, tags) {
      const v = (shift || "").trim();
      const t = (tags || []).filter((x) => x).join(", ");
      if (v && t) return `${v} + ${t}`;
      if (v) return v;
      if (t) return t;
      return "Empty";
    }

   function buildChangeLog(oldData, newData, weekRow, options = {}) {
  const includeUncovered = options.includeUncovered !== false; // default = true

  if (!oldData || !newData) return "";
  if (!Array.isArray(oldData.sections) || !Array.isArray(newData.sections)) return "";

  const lines = [];
  const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

  const oldSections = oldData.sections || [];
  const newSections = newData.sections || [];

  const sectionCount = Math.max(oldSections.length, newSections.length);

  for (let si = 0; si < sectionCount; si++) {
    const oldSection = oldSections[si] || { rows: [] };
    const newSection = newSections[si] || { rows: [] };

    const oldRows = oldSection.rows || [];
    const newRows = newSection.rows || [];
    const rowCount = Math.max(oldRows.length, newRows.length);

    for (let ri = 0; ri < rowCount; ri++) {
      const oRow = oldRows[ri] || { shifts: {}, tags: {} };
      const nRow = newRows[ri] || { shifts: {}, tags: {} };

      const name = (nRow.staff_name || oRow.staff_name || "").trim();
      if (!name) continue;

      days.forEach((dayKey) => {
        const oldShift = oRow.shifts?.[dayKey] || "";
        const newShift = nRow.shifts?.[dayKey] || "";

        const oldTags = normaliseCellTags(oRow, dayKey);
        const newTags = normaliseCellTags(nRow, dayKey);

        const sameShift = String(oldShift || "").trim() === String(newShift || "").trim();
        const sameTags =
          oldTags.length === newTags.length &&
          oldTags.every((t, idx) => t === newTags[idx]);

        if (sameShift && sameTags) return;

        const d = getDateForDay(weekRow.week_ending, dayKey);
        const dateStr = d ? formatUK(d.toISOString()) : dayKey.toUpperCase();

        const fromDesc = describeShiftAndTags(oldShift, oldTags);
        const toDesc = describeShiftAndTags(newShift, newTags);

        lines.push(`- ${name} ${dateStr}: ${fromDesc} -> ${toDesc}`);
      });
    }
  }

  if (!includeUncovered) {
    return lines.join("\n");
  }

  // Append current uncovered shifts (newData)
  const sections = newData.sections || [];
  const uncoveredLines = [];
  sections.forEach((section) => {
    ensureUncovered(section);
    days.forEach((dayKey) => {
      const u = section.uncovered?.[dayKey];
      if (!u) return;

      const slots =
        typeof u === "string"
          ? { s1: u, s2: "" }
          : { s1: u.s1 || "", s2: u.s2 || "" };

      ["s1", "s2"].forEach((slot) => {
        const val = (slots[slot] || "").trim();
        if (!val) return;
        const d = getDateForDay(weekRow.week_ending, dayKey);
        const dateStr = d ? formatUK(d.toISOString()) : dayKey.toUpperCase();
        const title = section.title || "Section";
        uncoveredLines.push(`- Uncovered: ${title} ${dateStr} (${slot.toUpperCase()}) ${val}`);
      });
    });
  });

  if (uncoveredLines.length) {
    if (lines.length) {
      lines.push("");
      lines.push("Uncovered shifts:");
    } else {
      lines.push("Uncovered shifts:");
    }
    uncoveredLines.forEach((l) => lines.push(l));
  }

  return lines.join("\n");
}

async function showChangeLog() {
  if (!currentWeek || !currentWeek.id) {
    alert("Open a week before viewing the change log.");
    return;
  }

  let revisions = [];
  try {
    const { data, error } = await supabase
      .from("roster_week_revisions")
      .select("id, week_id, snapshot, label, created_at")
      .eq("week_id", currentWeek.id)
      .order("created_at", { ascending: true });

    if (error) {
      console.error("showChangeLog load error", error);
      alert("Unable to load change log.");
      return;
    }
    revisions = data || [];
  } catch (e) {
    console.error("showChangeLog exception", e);
    alert("Unable to load change log.");
    return;
  }

  if (!revisions.length) {
    alert("No published versions recorded yet for this week.");
    return;
  }

  const lines = [];

  revisions.forEach((rev, idx) => {
    const versionNumber = idx + 1;
    const label = rev.label || `V${versionNumber}`;
    const when = rev.created_at ? formatUK(rev.created_at) : "Unknown date";

    lines.push(`Version ${label} (published ${when})`);
    lines.push("".padEnd(40, "-"));

    if (idx === 0) {
      // No previous snapshot to diff against
      lines.push("Initial publication from draft.");
    } else {
      const prevSnap = revisions[idx - 1].snapshot;
      const diffText = buildChangeLog(prevSnap, rev.snapshot, currentWeek, {
        includeUncovered: false
      });
      lines.push(diffText || "No changes detected.");
    }

    lines.push("");
  });

  // Current uncovered summary from the latest version
  const latest = revisions[revisions.length - 1];
  const uncoveredText = buildChangeLog(
    latest.snapshot,
    latest.snapshot,
    currentWeek,
    { includeUncovered: true }
  );

  if (uncoveredText && uncoveredText.trim()) {
    lines.push("");
    lines.push("Current uncovered shifts (latest version):");
    lines.push(uncoveredText);
  }

  const finalText = lines.join("\n");

  let win;
  try {
    win = window.open("", "_blank", "width=900,height=700");
  } catch (e) {
    console.warn("Unable to open window for change log", e);
  }

  if (win) {
    const safe = finalText
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
    win.document.write("<!doctype html><title>Roster change log</title>");
    win.document.write(
      "<pre style='font-family:system-ui,monospace;font-size:12px;white-space:pre-wrap;'>" +
        safe +
      "</pre>"
    );
    win.document.close();
  } else {
    console.log("Roster change log:\n" + finalText);
    alert("Change log written to console (could not open a new window).");
  }
}

    // ===== COVERAGE BANNER =====
    function computeWeekMetrics(weekRow) {
      const stats = { al: 0, cl: 0, sick: 0, rdwTotal: 0, rdwSun: 0, uncovered: 0 };
      if (!weekRow || !weekRow.data || !Array.isArray(weekRow.data.sections)) return stats;

      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
      weekRow.data.sections.forEach((section) => {
        ensureUncovered(section);

        days.forEach((day) => {
          const u = section.uncovered?.[day];

          if (typeof u === "string") {
            if (u.trim()) stats.uncovered += 1;
          } else if (u && typeof u === "object") {
            if ((u.s1 || "").trim()) stats.uncovered += 1;
            if ((u.s2 || "").trim()) stats.uncovered += 1;
          }
        });

        (section.rows || []).forEach((row) => {
          days.forEach((day) => {
            const shift = row.shifts?.[day];
            const v = (shift || "").toUpperCase();
            const tags = Array.isArray(row.tags?.[day]) ? row.tags[day] : [];
            const tagSet = new Set(tags.map((t) => String(t).toUpperCase()));

            if (!v && tagSet.size === 0) return;

            const hasAL = tagSet.has("AL") || v.includes("A/L");
            const hasCL = tagSet.has("CL") || v.includes("C/L");
            const hasSick = tagSet.has("SICK") || v.includes("SICK") || v.includes("S/L");

            if (hasAL) stats.al++;
            if (hasCL) stats.cl++;
            if (hasSick) stats.sick++;

            const isRDW = row.rdw && row.rdw[day];
            if (isRDW) {
              stats.rdwTotal++;
              if (day === "sun") stats.rdwSun++;
            }
          });
        });
      });

      return stats;
    }

    function updateCoverageBanner() {
      if (!currentWeek) {
        coveragePill.textContent = "Coverage: n/a";
        coveragePill.classList.remove("cov-good", "cov-amber", "cov-red");
        coverageSummary.textContent = "No metrics available yet.";
        return;
      }

      const stats = computeWeekMetrics(currentWeek);

      coveragePill.classList.remove("cov-good", "cov-amber", "cov-red");
      let label = "n/a";
      let cls = "";

      if (stats.uncovered === 0) {
        label = "Green";
        cls = "cov-good";
      } else if (stats.uncovered <= 4) {
        label = "Amber";
        cls = "cov-amber";
      } else {
        label = "Red";
        cls = "cov-red";
      }

      coveragePill.textContent = `Coverage: ${label}`;
      if (cls) coveragePill.classList.add(cls);

      coverageSummary.textContent =
        `Uncovered: ${stats.uncovered} • ` +
        `A/L: ${stats.al} • C/L: ${stats.cl} • Sick: ${stats.sick} • ` +
        `RDW: ${stats.rdwTotal} (Sun ${stats.rdwSun})`;
    }

    // ===== COMP LEAVE EXPIRY WATCH =====
    async function refreshExpiryWatch() {
      analyticsExpiryTbody.innerHTML = "";

      const today = new Date();
      const oneYearAgo = addDays(today, -365);

            const { data, error } = await supabase
        .from("roster_weeks")
        .select("id, week_ending, data")
        .eq("link", currentLink)
        .gte("week_ending", oneYearAgo.toISOString().slice(0, 10))
        .lte("week_ending", today.toISOString().slice(0, 10))
        .order("week_ending", { ascending: true });

      if (error) {
        console.error("refreshExpiryWatch error", error);
        return;
      }

      const expiryStats = computeExpiryFromWeeks(data || []);
      renderExpiryAnalytics(expiryStats);
    }

    function computeExpiryFromWeeks(weeks) {
      const usageMap = {};
      const days = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

      weeks.forEach((w) => {
        const struct = w.data;
        if (!struct || !Array.isArray(struct.sections)) return;

        struct.sections.forEach((section) => {
          (section.rows || []).forEach((row) => {
            const staffName = (row.staff_name || "").trim();
            if (!staffName) return;

            if (!usageMap[staffName]) {
              usageMap[staffName] = {
                name: staffName,
                lropEarned: [],
                clUsedCount: 0
              };
            }

            days.forEach((day) => {
              const shift = row.shifts?.[day];
              const v = (shift || "").toUpperCase();
              const tags = Array.isArray(row.tags?.[day]) ? row.tags[day] : [];
              const tagSet = new Set(tags.map((t) => String(t).toUpperCase()));
              if (!v && tagSet.size === 0) return;

              const hasCL = tagSet.has("CL") || v.includes("C/L");
              const hasLROP = tagSet.has("LROP") || v.includes("LROP");

              const dayDate = getDateForDay(w.week_ending, day);

              if (hasCL) {
                usageMap[staffName].clUsedCount++;
              }
              if (hasLROP && dayDate) {
                usageMap[staffName].lropEarned.push(dayDate);
              }
            });
          });
        });
      });

      const today = new Date();
      const horizon = addDays(today, COMP_EXPIRY_HORIZON_DAYS);

      const result = [];

      Object.values(usageMap).forEach((u) => {
        const credits = [...u.lropEarned].sort((a, b) => a - b);
        let remainingCredits = credits.map((d) => ({ date: d, consumed: false }));

        let used = u.clUsedCount || 0;
        for (let i = 0; i < remainingCredits.length && used > 0; i++) {
          if (!remainingCredits[i].consumed) {
            remainingCredits[i].consumed = true;
            used--;
          }
        }

        let expiringCount = 0;
        let firstExpiry = null;

        remainingCredits.forEach((c) => {
          if (c.consumed) return;
          const expiry = new Date(c.date.getTime());
          expiry.setFullYear(expiry.getFullYear() + 1);

          if (expiry >= today && expiry <= horizon) {
            expiringCount++;
            if (!firstExpiry || expiry < firstExpiry) {
              firstExpiry = expiry;
            }
          }
        });

        if (expiringCount > 0) {
          result.push({
            name: u.name,
            expiringCount,
            firstExpiry
          });
        }
      });

      result.sort((a, b) => a.firstExpiry - b.firstExpiry || a.name.localeCompare(b.name));
      return result;
    }

    function renderExpiryAnalytics(rows) {
      analyticsExpiryTbody.innerHTML = "";
      if (!rows.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="3" class="muted">No comp leave credits nearing expiry.</td>`;
        analyticsExpiryTbody.appendChild(tr);
        return;
      }

      rows.forEach((r) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td style="text-align:left;">${r.name}</td>
          <td>${r.expiringCount}</td>
          <td>${formatUK(r.firstExpiry.toISOString())}</td>
        `;
        analyticsExpiryTbody.appendChild(tr);
      });
    }

})();
  </script>
</body>
</html>
